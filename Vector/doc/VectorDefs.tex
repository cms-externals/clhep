% CLHEP/ZOOM Vector Package Formulas and Definitions

\documentclass[twoside,12pt]{article}
\flushbottom
\pagestyle{headings}

\setlength{\topmargin}{0.0in}
\setlength{\textwidth}{5.5in}
\setlength{\oddsidemargin}{.5in}
\setlength{\evensidemargin}{.5in}
\setlength{\textheight}{8.5in}

\addtolength{\parskip}{2pt}

\newcommand{\fpcl}{{\sc fpcl}}

\def \Point {{\tt Point3D}}
\def \Line {{\tt Line3D}}
\def \Direction {{\tt Direction}}
\def \UnitVector {{\tt UnitVector}}
\def \Plane {{\tt Plane3D}}
\def \SpaceVector {{\tt SpaceVector}}
\def \SV {{\tt Hep3Vector}}
\def \SVz {{\tt SpaceVector}}
\def \UV {{\tt UnitVector}}
\def \TangentVector {{\tt TangentVector}}
\def \TV {{\tt TangentVector}}
\def \Ro {{\tt HepRotation}}
\def \Ros {{\tt Rotation}}
\def \Rotation {{\tt Rotation}}
\def \RotationZ {{\tt HepRotationZ}}
\def \Transformation {{\tt Transformation}}
\def \Euclidean {{\tt EuclideanTransformation}}
\def \Angle {{\tt Angle}}
\def \LorentzVector {{\tt LorentzVector}}
\def \LorentzTransformation {{\tt LorentzTransformation}}
\def \LV {{\tt HepLorentzVector}}
\def \LVz {{\tt LorentzVector}}
\def \LT {{\tt HepLorentzRotation}}
\def \LTs {{\tt LorentzTransformation}}
\def \LB {{\tt HepBoost}}
\def \LBs {{\tt LorentzBoost}}
\def \PolarAngle {{\tt PolarAngle}}
\def \PAngle {{\tt PAngle}}
\def \AzimuthalAngle {{\tt AzimuthalAngle}}
\def \AAngle {{\tt AAngle}}
\def \EB {{\tt EBvector}}
\def \AV {{\tt Adjoint3Vector}}
\def \ALV {{\tt Adjoint4Vector}}
\def \Scalar {{\tt Scalar}}
\def \Ax {{\tt HepAxisAngle}}
\def \Es {{\tt HepEulerAngles}}

\newcommand {\see}[1] {\hfill$\triangleright$ see eqn.~#1}

\newenvironment{shortlist}{%
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
}{%
\end{itemize}
}

\setcounter{secnumdepth}{2}	% Number sub- but not subsubsections
\setcounter{tocdepth}{2}	% Only numbered section headings go in contents

\begin{document}

\title{CLHEP {\bf Vector} Package \\ 
and \\
ZOOM {\bf PhysicsVector} Package \\
Space and Lorentz Vector and Transformation Package \\
Formulas and Definitions}

\author{
Fermilab ``ZOOM'' Physics Class Library Task Force}
\date{Version 2.3, September 2, 2003}
\maketitle

The CLHEP Vector package implements 3-vectors, 4-vectors, rotations, 
Lorentz transfomations and related concepts.  
This includes all functionallity in the original CLHEP package, and in
the ZOOM PhysicsVectors package.  
The latter is now implemented as wrapper headers, so that classes from
the ZOOM package can be used wherever the corresponding CLHEP class are
expected.

This document briefly lists the methods available, then presents relevant
mathematical definitions. 

\tableofcontents

\section{Available Classes and Methods}

In this document we somewhat abbreviate the signatures of methods,
since coders will look at the header files anyway.  
Any arguments specified without an explicit data type
are of the scalar type {\tt HepDouble}, which is just {\tt double} on
virtually every system.
Unless otherwise indicated,
parameter passage for scalars is by value,
and parameter passage for other types is by constant reference.
This document also does not discuss namespace issues.

\subsection{\protect\SV\ Class --- Vector of real quantities in 3-space}

Throughout this section,
arguments named v, v1, v2, etc., are of type \SV .

\subsubsection{Constructors and Accessors}

\begin{shortlist}
  \item Hep3Vector(~)
  \item Hep3Vector( x, y, z ) 
\end{shortlist}

\noindent
The following accessor methods are used
to obtain the named coordinate components,
as in \verb|double s = v.r();|.

\begin{shortlist}
  \item x(~) \/\/\/ y(~) \/\/\/ z(~) 
  \item r(~) \see{\ref{eq:polar}}
  \item theta(~) \see{\ref{eq:polar}}
  \item eta(~) \see{\ref{eq:spherical}}
  \item phi(~) \see{\ref{eq:polar}, \ref{eq:cylindrical}}
  \item rho(~) \see{\ref{eq:cylindrical}}
  \item getX(~) \/\/\/ getY(~) \/\/\/ getZ(~) 
  \item getR(~) \/\/\/ getTheta(~) \/\/\/ getPhi(~)
  \item getEta(~) \/\/\/ getRho(~)
\end{shortlist}

\noindent
The Cartesian components may also be accessed by the index syntax, 
using either square braces or parentheses.  
In either case, the meaning of the index is 0-based, 
and an enum is provided to help clarify this: {\tt Hep3Vector::X=0},
{\tt Hep3Vector::Y=1}, {\tt Hep3Vector::Z=2}.

\noindent
There is a family of methods of the form
{\tt set}{\it Component}{\tt ()} which may be used to set 
one component in Cartesian or Polar coordinates, keeping the other
two constant.  
Also available is {\tt setCylTheta()}, which modifies $\theta$ (the angle
against the Z axis) while keeing $\phi$ and the radial distance from the 
Z axis $\rho$ constant.

\noindent
Finally, there is also a family of {\tt set()} methods
that may be used to update all of a \SV 's three coordinates at once.
These {\tt set()} methods' signatures are in one-to-one correspondence
with the non-default constructors listed above.

\subsubsection{Operators}

For \SV s v, v1, and v2, and for a scalar c,
the following arithmetic operations are provided,
in each case resulting in a \SV .

\begin{shortlist}
  \item v1 + v2  and  v1 $-$ v2
  \item v $*$ c  and  c $*$ v
  \item v / c
  \item $-$ v
\end{shortlist}

\noindent
In addition, 
the following arithmetic modify-assignment operations are provided.

\begin{shortlist}
  \item v1 += v2  and  v1 $-$= v2
  \item v $*$= c  and  v /= c
\end{shortlist}

\noindent
The usual six relational operations
(==, !=, $<$, $<=$, $>$, $>=$) are provided (see eqn. \ref{eq:compSV}).
Further, the following member functions are useful to check for equality
within a relative tolerance.

\begin{shortlist}
  \item bool isNear( v, epsilon ) \see{\ref{eq:isNear}}
  \item Scalar howNear( v ) \see{\ref{eq:howNear}, \ref{eq:howNear:2}, \ref{eq:howNear:3}}
  \item Scalar deltaR( v ) \see{\ref{eq:deltaR}}
\end{shortlist}

\noindent
The tolerance epsilon may be omitted.
The following class-wide (static) functions are used
to obtain and set the default tolerance for nearness.

\begin{shortlist}
  \item HepDouble setTolerance( tol )	\see{\ref{eq:epsildef}}
  \item HepDouble getTolerance(~)
\end{shortlist}


\subsubsection{Methods}

\begin{shortlist}
  \item ostream \& operator$<<$( ostream \& os, v )
  \item istream \& operator$>>$( istream \& is, Hep3Vector \& v )
\end{shortlist}
\begin{shortlist}
  \item HepDouble dot( v ) \see{\ref{eq:dot}}
  \item Hep3Vector cross( v ) \see{\ref{eq:cross}}
  \item HepDouble diff2( v ) \see{\ref{eq:diff2}}
  \item bool isParallel( v, epsilon ) \see{\ref{eq:isPar}}
  \item bool isOrthogonal( v, epsilon ) \see{\ref{eq:isOrtho}}
  \item HepDouble howParallel( v ) \see{\ref{eq:howPar}, \ref{eq:howPar:2}}
  \item HepDouble howOrthogonal( v ) \see{\ref{eq:howOrtho}, \ref{eq:howOrtho:2}}
\end{shortlist}

\begin{shortlist}
  \item HepDouble mag2(~) \see{\ref{eq:mag2}}
  \item HepDouble mag(~) \see{\ref{eq:mag}, \ref{eq:mag:2}}
  \item HepDouble beta(~) \see{\ref{eq:beta}}
  \item HepDouble gamma(~) \see{\ref{eq:gamma}}
  \item HepDouble pseudoRapidity(~) \see{\ref{eq:spherical}}
  \item HepDouble coLinearRapidity(~) \see{\ref{eq:coLinRap}}
  \item Hep3Vector unit(~) \see{\ref{eq:svunit}}
  \item Hep3Vector orthogonal(~) \see{\ref{eq:orthogonal}}
\end{shortlist}

\noindent
The following methods depend on a reference direction
(specified by a \SV\ u).  Signatures omitting
the reference direction are also supplied---$\hat{z}$ is implied in these
cases and the methods take advantage of the simpler form.

\begin{shortlist}
  \item HepDouble perp( u ) \see{\ref{eq:perp}}
  \item HepDouble perp2( u ) \see{\ref{eq:perp2}}
  \item SpaceVector perpPart( u ) \see{\ref{eq:perpPart}}
  \item SpaceVector project( u ) \see{\ref{eq:project}}
  \item HepDouble angle( u ) \see{\ref{eq:angle}}
  \item HepDouble theta( u ) \see{\ref{eq:theta}}
  \item HepDouble cosTheta( u ) \see{\ref{eq:cosTheta}}
  \item HepDouble cos2Theta( u ) \see{\ref{eq:cos2Theta}}
  \item HepDouble eta( u ) \see{\ref{eq:eta}, \ref{eq:eta:2}, \ref{eq:eta:3}, \ref{eq:eta:4}}
  \item HepDouble polarAngle( v2, u ) \see{\ref{eq:polarA}, \ref{eq:polarA:2}}
  \item HepDouble deltaPhi( v2 ) \see{\ref{eq:azim}}
  \item HepDouble azimAngle( v2, u ) \see{\ref{eq:azim}, \ref{eq:azim:2}}
  \item HepDouble rapidity( u ) \see{\ref{eq:rap}, \ref{eq:rap:2}}
\end{shortlist}

\subsubsection{Rotations}

\noindent
These methods change the vector:

\begin{shortlist}
  \item Hep3Vector \& rotateX( delta ) \see{\ref{eq:rotX}}
  \item Hep3Vector \& rotateY( delta ) \see{\ref{eq:rotY}}
  \item Hep3Vector \& rotateZ( delta ) \see{\ref{eq:rotZ}, \ref{eq:rotZ:2}}
  \item Hep3Vector \& rotateUZ( Hep3Vector ) \see{\ref{eq:rotUz}}
\end{shortlist}

\begin{shortlist}
  \item Hep3Vector \& rotate( axis, delta ) \see{\ref{eq:axisrot}}
  \item Hep3Vector \& rotate( const AxisAngle \& ax ) \see{\ref{eq:axisrot}}
  \item Hep3Vector \& rotate( phi, theta, psi ) \see{\ref{eq:eulerrot}}
  \item Hep3Vector \& rotate( const EulerAngles \& e ) \see{\ref{eq:eulerrot}}
\end{shortlist}

\noindent 
The following methods both do $\vec{v} \Longleftarrow R v$.  
(Notice the order of multiplication for {\tt v *= R}.)

\begin{shortlist}
  \item Hep3Vector transform   (const HepRotation \& R) \see{\ref{eq:opstareq}}
  \item Hep3Vector operator *= (const HepRotation \& R) \see{\ref{eq:opstareq}}
\end{shortlist}


\noindent
These global functions do not change the \SV\ v:

\begin{shortlist}
  \item Hep3Vector rotationXOf( v, delta ) \see{\ref{eq:rotX}}
  \item Hep3Vector rotationYOf( v, delta ) \see{\ref{eq:rotY}}
  \item Hep3Vector rotationZOf( v, delta ) \see{\ref{eq:rotZ}, \ref{eq:rotZ:2}}
\end{shortlist}

\begin{shortlist}
  \item Hep3Vector rotationOf( v, axis, delta ) \see{\ref{eq:axisrot}}
  \item Hep3Vector rotationOf( v, const AxisAngle \& ax ) \see{\ref{eq:axisrot}}
  \item Hep3Vector rotationOf( v, phi, theta, psi ) \see{\ref{eq:eulerrot}}
  \item Hep3Vector rotationOf( v, const EulerAngles \& e ) \see{\ref{eq:eulerrot}}
\end{shortlist}

\subsection{\protect\SVz\ Class --- Derived from \SV }

The \SVz\ class provides backward compatibility with the original ZOOM
PhysicsVectors package.  
It is publicly derived from \SV .
It would simply be a typedef off \SV , in the appropriate namespace, 
but for one set of features which were felt to be overkill in the 
CLHEP context.  
This is the ability to construct a \SVz\ providing spherical or cylindrical
coordinates.  

Associated with these constructors are a set of defined keywords which
allow disambiguation of the various forms of constructors.  
These keywords are {\tt RADIANS}, {\tt DEGREES}, and {\tt ETA}, 

Throughout this section, we will illustrate using {\tt RADIANS}, 
but this may be replaced by {\tt DEGREES}
to indicate the corresponding angle's units.
For theta, this may also be replaced by {\tt ETA}, to indicate that the
pseudorapidity is being supplied.

\begin{shortlist}
  \item SpaceVector(~)
  \item SpaceVector( x, y, z ) 
  \item SpaceVector( r, theta, RADIANS, phi, RADIANS ) \see{\ref{eq:polar}}
  \item SpaceVector( rho, phi, RADIANS, z ) \see{\ref{eq:cylindrical}}
\end{shortlist}


\subsection{\protect\UV\ Class}

It was found useful in the ZOOM package to express the concept of a 
\UV, that is, a vector known to be inherently of unit length.
CLHEP neither has such a class, and it is felt (at this time) that
it should not.  
In the merged package, 
\UV\ is provided as a header file which appears only in the PhysicsVectors 
area.  

Since \UV\ depends on no non-header implementation code, issues of where
to place the library containing non-CLHEP code do not arise.

Although the \UV\ class is not derived from the \SVz\ class,
all const methods (except for three relativistic kinematic methods
which only make sense for a vector of length less than one) 
are provided for \UV .
Thos non-const methods of \SV\ which do not risk violating the unit-length 
property, such as rotation, are also provided.  
In this section, therefore,
only the differences in the classes are described.

\subsubsection{Constructors and Accessors}

\UV\ constructors (and \verb|set()| methods)
have the same signatures as do the corresponding \SVz\ methods,
but normalize before returning.
The default \UV\ constructor yields $\hat{z}$.
In addition, we have the conversion constructor
\begin{shortlist}
  \item UnitVector( Hep3Vector v )
\end{shortlist}

\noindent
Unlike the case for \SV , \UV\ disallows setting a
single Cartesian coordinate.  Also, of course,
modifying the radius of a \UV\ is forbidden.

\subsubsection{Operators}

\UV s are treated as \SV s for purposes of arithmetic and comparisons,
except that unary minus returns a \UV .
Modify-assignment (e.g., +=) is forbidden on \UV s.

\subsubsection{Methods}
\label{unitMethods}

Most \UV\ methods match those of the \SV\ class; some are modified,
however, to take advantage of the r~=~1 property.
Forbidden methods include
\verb|beta()|, \verb|gamma()|, and \verb|rapidity()|.

\subsubsection{Rotations}

All methods and functions in this category apply equally to
\UV s as they do to \SV s.



\subsection{\protect\LV\ Class --- Vector of real quantities in 4-space}

Throughout this section,
arguments named p, p1, p2, etc., are of type \LV ,
arguments named v, v1, v2, etc., are of type \SV ,
and an argument named t will refer to a scalar meant as a time component.

\subsubsection{Constructors and Accessors}

\begin{shortlist}
  \item HepLorentzVector(~)
  \item HepLorentzVector( x, y, z, t )
  \item HepLorentzVector( v, t )
  \item HepLorentzVector( t, v )
  \item HepLorentzVector( t )
  \item HepLorentzVector( x, y, z )
  \item HepLorentzVector( v )
\end{shortlist}

\noindent
The following accessor methods are used
to obtain the named coordinate components,
as in \verb|double s = p.t();|.
\begin{shortlist}
  \item x(~) \/\/\/ y(~) \/\/\/ z(~) \/\/\/ t(~)
  \item px(~) \/\/\/ py(~) \/\/\/ pz(~) \/\/\/ e(~)
  \item getX(~) \/\/\/ getY(~) \/\/\/ getZ(~) \/\/\/ getT(~)
  \item v(~) or getV(~) or vect(~)
\end{shortlist}


\noindent
The Cartesian components may also be accessed by the index syntax, 
using either square braces or parentheses.  
In either case, the meaning of the index is 0-based, {\em with the
time component last}.
An enum is nested in the {\tt HepLorentzVector} class to help clarify this: 
{\tt X=0}, {\tt Y=1}, {\tt Z=2}, {\tt T=3}.

The spatial components can also be accessed in spherical coordinates:
\begin{shortlist}
  \item HepDouble theta() const;
  \item HepDouble cosTheta() const;
  \item HepDouble phi() const;
  \item HepDouble rho() const;
\end{shortlist}

\noindent
There is a family of methods of the form
{\tt set}{\it Component}{\tt ()} which may be used to set 
one component in Cartesian or spherical coordinates, or the $\rho$
cylindrical coordinate,
keeping the other components in that system constant.  
\begin{shortlist}
  \item setX(HepDouble);  \/\/\/ setPx(HepDouble);  
  \item setY(HepDouble);  \/\/\/ setPy(HepDouble);  
  \item setZ(HepDouble);  \/\/\/ setPz(HepDouble);  
  \item setT(HepDouble);  \/\/\/ setE(HepDouble);  
  \item setTheta(HepDouble); \see{\ref{eq:polar}}
  \item setPhi(HepDouble);   \see{\ref{eq:polar}}
  \item setRho(HepDouble); \/\/\/  setPerp(HepDouble); 
						\see{\ref{eq:cylindrical}}
\end{shortlist}

The entire spatial component can be set at once, keeping the time component 
constant.

\begin{shortlist}
  \item setVect(HepDouble);  \/\/\/ setV(HepDouble);  
\end{shortlist}

\noindent
And there is a family of {\tt set()} methods, corresponding to the 
constructors,
that may be used to update all four of a \LV 's coordinates at once.
\begin{shortlist}
  \item set (x, y, z, t);
  \item set (v, t);
  \item set (t, x);
\end{shortlist}

\noindent
Assignment from a \SV\ is supported, as in \verb|p = v;|.

\noindent
Finally, there are conversion operators to const and non-const Hep3Vector;
these were present in the original CLHEP classes.  
They ignore the time component.

\subsubsection{Operators}

For \LV s p, p1, and p2, and for a scalar c,
the following arithmetic operations are provided,
in each case resulting in a \LV .

\begin{shortlist}
  \item p1 + p2  and  p1 $-$ p2
  \item p $*$ c  and  c $*$ p
  \item p / c
  \item $-$ p
\end{shortlist}

\noindent
In addition, the following arithmetic modify-assignment operations are provided.

\begin{shortlist}
  \item p1 += p2  and  p1 $-$= p2
  \item p $*$= c  and  p /= c
\end{shortlist}

The usual six relational operations
(==, !=, $<$, $<=$, $>$, $>=$) are provided (see eqn. \ref{eq:wcomp}).
Further, the following member functions are useful
to check for equality, etc., within a relative tolerance.

\begin{shortlist}
  \item bool isNear( p, epsilon ) \see{\ref{eq:wisNear}}
  \item HepDouble howNear( p ) \see{\ref{eq:whowNear}, \ref{eq:whowNear:2}}
  \item bool isNearCM( p, epsilon ) \see{\ref{eq:wisNearCM}, \ref{eq:wisNearCM:2}}
  \item HepDouble howNearCM( p ) \see{\ref{eq:whowNearCM}, \ref{eq:whowNearCM:2}}
  \item bool isParallel( p, epsilon ) \see{\ref{eq:wisPar}, \ref{eq:wisPar:2}}
  \item HepDouble howParallel( p) \see{\ref{eq:whowPar}, \ref{eq:whowPar:2}}
  \item HepDouble deltaR( p ) \see{\ref{eq:deltaR}}
\end{shortlist}

\noindent
The tolerance epsilon may be omitted.
The following class-wide (static) functions are used
to obtain and set the default tolerance for nearness.

\begin{shortlist}
  \item HepDouble setTolerance( HepDouble tol )
  \item HepDouble getTolerance(~)
\end{shortlist}

\subsubsection{Methods}

\noindent
Establishing a metric convention (static):

\begin{shortlist}
  \item ZMpvMetric\_t setMetric( ZMpvMetric\_t m )
  \item ZMpvMetric\_t getMetric(~)
\end{shortlist}

\noindent
Metric-independent properties and methods of this 4-vector
(the results of these methods do not change sign if you go from the
TimePositive to the TimeNegative metric):
\begin{shortlist}
  \item ostream \& operator$<<$( ostream \& os, p )
  \item istream \& operator$>>$( istream \& is, LorentzVector \& p )
  \item bool isSpacelike(~) \see{\ref{eq:wisSl}}
  \item bool isTimelike(~) \see{\ref{eq:wisTl}}
  \item bool isLightlike( epsilon ) \see{\ref{eq:wisLl}}
  \item HepDouble howLightlike(~) \see{\ref{eq:whowLl}, \ref{eq:whowLl:2}}
  \item HepDouble plus(~)  \see{\ref{eq:wplus}}
  \item HepDouble minus(~) \see{\ref{eq:wminus}}
  \item HepDouble euclideanNorm2(~)  \see{\ref{eq:wENorm2}}
  \item HepDouble euclideanNorm(~)  \see{\ref{eq:wENorm}}
  \item HepDouble restMass2(~) \see{\ref{eq:wrestM2}}
  \item HepDouble restMass(~) \see{\ref{eq:wrestM}}
  \item HepDouble m2(~) \see{\ref{eq:winvMass2}}
  \item HepDouble invariantMass2(~) \see{\ref{eq:winvMass2}}
  \item HepDouble m(~) \/\/\/ mag(~) \see{\ref{eq:wmag}}
  \item HepDouble invariantMass(~) \see{\ref{eq:winvMass}}
  \item HepDouble mt2(~) \see{\ref{eq:wmt2}}
  \item HepDouble mt(~) \see{\ref{eq:wmt}}
  \item HepDouble et2(~) \see{\ref{eq:wet2}}
  \item HepDouble et(~) \see{\ref{eq:wet}}
  \item LorentzVector rest4Vector(~) \see{\ref{eq:wrest4V}}
  \item SpaceVector boostVector(~) \see{\ref{boostvector}}
  \item HepDouble beta(~) \see{\ref{eq:wbeta}}
  \item HepDouble gamma(~) \see{\ref{eq:wgamma}}
  \item HepDouble eta(~) \see{\ref{eq:weta}, \ref{eq:weta:2}, \ref{eq:weta:3}}
  \item HepDouble rapidity(~) \see{\ref{eq:wrapid}, \ref{eq:wrapid:2}}
  \item HepDouble coLinearRapidity(~) \see{\ref{eq:wcoLinRap}, \ref{eq:wcoLinRap:2}}
  \item SpaceVector findBoostToCM(~) \see{\ref{eq:wfindBoost}}
\end{shortlist}

\noindent
Metric-dependent properties of this 4-vector:
(the results of these methods change sign if you go from the
TimePositive to the TimeNegative metric):
\begin{shortlist}
  \item HepDouble mag2(~) \see{\ref{eq:wmag2}}
\end{shortlist}

\noindent
Metric-independent methods combining two 4-vectors:
\begin{shortlist}
  \item HepDouble delta2Euclidean( p ) \see{\ref{eq:wdelta2E}}
  \item HepDouble plus( p ) \see{\ref{eq:wplus:2}}
  \item HepDouble minus( p ) \see{\ref{eq:wminus:2}}
  \item HepDouble eta( p ) \see{\ref{eq:weta}, \ref{eq:weta:2}, \ref{eq:weta:3}, \ref{eq:weta:4}}
  \item HepDouble rapidity( p ) \see{\ref{eq:wrapid}, \ref{eq:wrapid:2}, \ref{eq:wrapid:3}, \ref{eq:wrapid:4}}  
  \item HepDouble invariantMass2( p ) \see{\ref{eq:winvMass2}}
  \item HepDouble invariantMass( p ) \see{\ref{eq:winvMass}}
  \item SpaceVector findBoostToCM( p ) \see{\ref{eq:wfindBoost}}
\end{shortlist}

\noindent
Metric-dependent methods combining two 4-vectors:
\begin{shortlist}
  \item HepDouble dot( p ) \see{\ref{eq:wdot}, \ref{eq:wdot:2}}
  \item HepDouble operator*( p ) \see{\ref{eq:wdot}, \ref{eq:wdot:2}}
  \item HepDouble diff2( p ) \see{\ref{eq:wdiff2}}
\end{shortlist}


\noindent 
Methods involving properties of the spatial part of the 4-vector
(these could be invoked as p.v().whatever() but the p.whatever()
syntax is shorter).  
Most of these take a reference direction v; if v is omitted,
$\hat{z}$ is implied and the methods take advantage of the simpler form.
\begin{shortlist}
  \item HepDouble perp( v ) \see{\ref{eq:perp}}
  \item HepDouble perp2( v ) \see{\ref{eq:perp2}}
  \item HepDouble angle(~) \see{\ref{eq:angle}}
  \item setVectM(HepDouble); \/\/\/  setVectMag(HepDouble); 
						\see{\ref{eq:polar}}
  \item setRho(HepDouble); \/\/\/  setPerp(HepDouble); 
						\see{\ref{eq:cylindrical}}
  \item HepDouble pseudoRapidity(~) \see{\ref{eq:spherical}}
\end{shortlist}


\subsubsection{Rotations and Boosts}

These methods change the 4-vector.

\begin{shortlist}
  \item LorentzVector \& rotateX( delta ) \see{\ref{eq:rotX}}
  \item LorentzVector \& rotateY( delta ) \see{\ref{eq:rotY}}
  \item LorentzVector \& rotateZ( delta ) \see{\ref{eq:rotZ}}
  \item LorentzVector \& rotate( v, delta ) \see{\ref{eq:axisrot}}
  \item LorentzVector \& rotate( delta, v ) \see{\ref{eq:axisrot}}
  \item LorentzVector \& rotate( phi, theta, psi ) \see{\ref{eq:eulerrot}}
  \item LorentzVector \& rotate( EulerAngles \& e ) \see{\ref{eq:eulerrot}}
  \item LorentzVector \& rotateUz( v ) \see{\ref{eq:rotUz}}
  \item LorentzVector \& boostX( beta ) \see{\ref{eq:wbX}}
  \item LorentzVector \& boostY( beta ) \see{\ref{eq:wbY}}
  \item LorentzVector \& boostZ( beta ) \see{\ref{eq:wbZ}}
  \item LorentzVector \& boost( v ) \see{\ref{eq:wboostvec}}
  \item LorentzVector \& boost( v, beta ) \see{\ref{eq:pureboost}}
\end{shortlist}


\noindent 
The following methods all do $\vec{p} \Longleftarrow R p$ where $R$ is
either a \Ro or a \LT .
(Notice the order of multiplication for {\tt p *= R}.)

\begin{shortlist}
  \item HepLorentzVector transform   (const HepRotation \& R) 
		\see{\ref{eq:wopstareq}}
  \item HepLorentzVector operator *= (const HepRotation \& R) 
		\see{\ref{eq:wopstareq}}
  \item HepLorentzVector transform   (const HepLorentzRotation \& R) 
		\see{\ref{eq:wopstareq}}
  \item HepLorentzVector operator *= (const HepLorentzRotation \& R) 
		\see{\ref{eq:wopstareq}}
\end{shortlist}


\noindent
These functions return a new 4-vector.

\begin{shortlist}
  \item LorentzVector rotationXOf( p, delta ) \see{\ref{eq:rotX}}
  \item LorentzVector rotationYOf( p, delta ) \see{\ref{eq:rotY}}
  \item LorentzVector rotationZOf( p, delta ) \see{\ref{eq:rotZ}}
  \item LorentzVector rotationOf( p, v, delta ) \see{\ref{eq:axisrot}}

  \item LorentzVector rotationOf( p, phi, theta, psi ) \see{\ref{eq:eulerrot}}
  \item LorentzVector rotationOf( p, const EulerAngles \& e ) \see{\ref{eq:eulerrot}}

  \item LorentzVector boostXOf( p, beta ) \see{\ref{eq:wbX}}
  \item LorentzVector boostYOf( p, beta ) \see{\ref{eq:wbY}}
  \item LorentzVector boostZOf( p, beta ) \see{\ref{eq:wbZ}}
  \item LorentzVector boostOf( p, betaVector ) \see{\ref{eq:wboostvec}}
  \item LorentzVector boostOf( p, v, beta ) \see{\ref{eq:pureboost}}
\end{shortlist}


\subsection{\protect\LVz\ Class --- Typedefed from \LV }

The \LVz\ class provides backward compatibility with the original ZOOM
PhysicsVectors package.  
It is simply a typedef off \LV , in the appropriate namespace.
This is because there were no features or constructors in the ZOOM 
product which were felt to be 
overkill in the CLHEP context.  

\subsection{{\tt Hep2Vector} Class}

The {\tt Hep2Vector} class is a simple plane vector.
Throughout this section, arguments named s, s1, s2, etc., are of type 
{\tt Hep2Vector}.

\subsubsection{Constructors and Accessors}

\begin{shortlist}
  \item Hep2Vector(~)
  \item Hep2Vector( x, y ) 
  \item Hep2Vector( Hep3Vector v ) 
\end{shortlist}

\noindent
That last constructor will supress the Z component of $\vec{v}$.

Cartesian and polar coordinates may be accessed; these are identical to those 
of a \SV, with the Z component fixed at zero.  

\begin{shortlist}
  \item x(~) \/\/\/ y(~) 
  \item r(~) \see{\ref{eq:polar}}
  \item phi(~) \see{\ref{eq:polar}}
\end{shortlist}

\noindent
The Cartesian components may also be accessed by the index syntax, 
using either square braces or parentheses.  
In either case, the meaning of the index is 0-based, 
and an enum is provided to help clarify this: {\tt Hep2Vector::X=0},
{\tt Hep2Vector::Y=1}.

\noindent
There is a family of methods of the form
{\tt set}{\it Component}{\tt ()} which may be used to set 
one component in Cartesian or Polar coordinates, keeping the other
component constant.  

\begin{shortlist}
  \item setX(x) \/\/\/ setY(y) 
  \item setR(r) \/\/\/ setMag(r) \see{\ref{eq:polar}}
  \item setPhi(phi) 		 \see{\ref{eq:polar}}
\end{shortlist}

\noindent
Finally, there is also a family of {\tt set()} methods
that may be used to update all of a \SV 's three coordinates at once.
These {\tt set()} methods' signatures are in one-to-one correspondence
with the non-default constructors listed above.

\subsubsection{Operators}

For {\tt Hep2Vector}s s, s1, and s2, and for a scalar c,
the following arithmetic operations are provided,
in each case resulting in a {\tt Hep2Vector}.

\begin{shortlist}
  \item s1 + s2  and  s1 $-$ s2
  \item s $*$ c  and  c $*$ s
  \item s / c
  \item $-$ s
\end{shortlist}

\noindent
In addition, 
the following arithmetic modify-assignment operations are provided.

\begin{shortlist}
  \item s1 += s2  and  v1 $-$= s2
  \item s $*$= c  and  v /= c
\end{shortlist}

\noindent
The usual six relational operations
(==, !=, $<$, $<=$, $>$, $>=$) are provided (see eqn. \ref{eq:compSV}).
Further, the following member functions are useful to check for equality
within a relative tolerance.  (Again, these match the corresponding methods 
for \SV, with Z-component pinned at zero.)

\begin{shortlist}
  \item bool isNear( v, epsilon ) \see{\ref{eq:isNear}}
  \item Scalar howNear( v ) \see{\ref{eq:howNear}, \ref{eq:howNear:2}, \ref{eq:howNear:3}}
  \item Scalar deltaR( v ) \see{\ref{eq:deltaR}}
\end{shortlist}

\noindent
The tolerance epsilon may be omitted.
The following class-wide (static) functions are used
to obtain and set the default tolerance for nearness.

\begin{shortlist}
  \item HepDouble setTolerance( tol )	\see{\ref{eq:epsildef}}
  \item HepDouble getTolerance(~)
\end{shortlist}


\subsubsection{Methods}

The set of methods is somewhat simpler that for \SV, but in all applicable
cases the definitions match those for \SV:

\begin{shortlist}
  \item ostream \& operator$<<$( ostream \& os, s )
\end{shortlist}
\begin{shortlist}
  \item HepDouble dot( v ) \see{\ref{eq:dot}}
  \item bool isParallel( v, epsilon ) \see{\ref{eq:isPar}}
  \item bool isOrthogonal( v, epsilon ) \see{\ref{eq:isOrtho}}
  \item HepDouble howParallel( v ) \see{\ref{eq:howPar}, \ref{eq:howPar:2}}
  \item HepDouble howOrthogonal( v ) \see{\ref{eq:howOrtho}, \ref{eq:howOrtho:2}}
  \item HepDouble angle( s2 ) \see{\ref{eq:angle}}
\end{shortlist}

\begin{shortlist}
  \item HepDouble mag2(~) \see{\ref{eq:mag2}}
  \item HepDouble mag(~) \see{\ref{eq:mag}, \ref{eq:mag:2}}
  \item Hep2Vector unit(~) \see{\ref{eq:svunit}}
\end{shortlist}

\noindent
There is one method which is applicable for {\tt Hep2Vector} but which 
does not match the definition for \SV:

\begin{shortlist}
  \item Hep2Vector orthogonal(~) 
\end{shortlist}

\noindent
\verb$s.orthogonal()$ is $s$ rotated clockwise by $90^\circ$ if 
$|s_x| < |s_y|$, and counterclockwise by $90^\circ$ if 
$|s_x| \geq |s_y|$, and counterclockwise.

\vspace{.16 in}

In the ZOOM area, the class {\tt PlaneVector} is typedefed to 
{\tt Hep2Vector}.

                                   
\subsection{\protect\Ro\ Classes}

Throughout this section, arguments named r, r1, r2, etc., are of type \Ro.
Also, rowX, rowY, rowZ, colX, colY, colZ will represent \SV\ arguments.

\subsubsection{Constructors and Accessors}

\begin{shortlist}
% // construct an identity rotation by default:
  \item Rotation(~)

% // copy/assign any rotation:
  \item Rotation( r )
  \item Rotation \& operator=( r )
  \item Rotation \& set( r )

% // supply three Euler angles(in radians):
  \item Rotation( phi, theta, psi )			\see{\ref{eq:eulerrot}}
  \item Rotation \& set( phi, theta, psi )		\see{\ref{eq:eulerrot}}

% // supply EulerAngles structure:
  \item Rotation( const EulerAngles \& e )		\see{\ref{eq:eulerrot}}
  \item Rotation \& set( const EulerAngles \& e )	\see{\ref{eq:eulerrot}}

% // supply axis and angle:
  \item Rotation( const Hep3Vector \& axis, delta )	\see{\ref{eq:axisrot}}
  \item Rotation \& set( const Hep3Vector \& axis, delta ) \see{\ref{eq:axisrot}}

% // supply AxisAngle structure:
  \item Rotation( const AxisAngle \& ax )		\see{\ref{eq:axisrot}}
  \item Rotation \& set( const AxisAngle \& ax )	\see{\ref{eq:axisrot}}

% // supply three *orthogonal* UnitVectors for the columns:
  \item Rotation( colX, colY, colZ )  
  \item Rotation \& set( colX, colY, colZ )
  \item Rotation \& setRows( rowX, rowY, rowZ )
% // NOTE:	
% //		This constructor and set method will check that the
% //		cols form an orthonormal matrix, and adjust so that
% //		relation is as exact as possible.

% // supply ZMpvRep3x3 structure:
  \item Rotation( const ZMpvRep3x3 \& rep )
  \item Rotation \& set( const ZMpvRep3x3 \& rep )
% // WARNING:
% //		This constructor and set method will assume the
% //		ZMpvRep3x3 supplied is infact an orthogonal matrix.
% //		No checking or correction is done. If you are
% //		not certain the matrix is orthogonal, break it
% //		into three SpaceVector cols and use the form
% //		Rotation(UnitVector, UnitVector, UnitVector)

\end{shortlist}

\begin{shortlist}
  \item phi(~) \/\/\/ theta(~) \/\/\/ psi(~) 
		\see{\ref{eq:eulerrot},\ref{eq:phipsiconv},\ref{eq:thetaconv}}
  \item eulerAngles(~) 	
		\see{\ref{eq:eulerrot},\ref{eq:phipsiconv},\ref{eq:thetaconv}}
  \item axis(~)	\/\/\/ delta(~)
  \item axisAngle(~) 		\see{\ref{eq:axisrot},\ref{eq:deltaconv}}
%// for orthogonal unit vectors
  \item colX(~) \/\/\/ colY(~) \/\/\/ colZ(~) 
  \item rowX(~) \/\/\/ rowY(~) \/\/\/ rowZ(~) 
% // for individual elements:
  \item xx(~) \/\/\/ xy(~) \/\/\/ xz(~) 
  \item yx(~) \/\/\/ yy(~) \/\/\/ yz(~) 
  \item zx(~) \/\/\/ zy(~) \/\/\/ zz(~) 

% // for all 9 elements:
  \item HepRep3x3 rep3x3(~) 	

% // for a 16-element xyzt matrix:
  \item HepRep4x4 rep4x4(~) 

\end{shortlist}

And the matrix elements of a \Ro\ may be accessed using two integer indices
in parentheses or square brackets, with indices running from 0 to 2.

The following methods alter one component of a \Ro, in some way of viewing 
that rotation:

\begin{shortlist}
  \item setPhi(HepDouble) \/\/\/ setTheta(HepDouble) \/\/\/ setPsi(HepDouble) 
		\see{\ref{eq:eulerrotR}}
  \item setAxis(Hep3Vector)	\/\/\/ setDelta(Hep3Vector)
		\see{\ref{eq:axisrotR}}
\end{shortlist}


\subsubsection{Use of \protect\Ro\ as a 4-Rotation}

The \Ro\ may be considered to be a 4-rotation.  Thus, other accessors 
applicable to \LT\ (see section (\ref{ltmethods}))
may be applied to \Ro\ as well.


\subsubsection{Operators and Methods}

% // arithmetic:
\begin{shortlist}
  \item Rotation \& operator\verb$*=$( r )
  \item friend Rotation operator$*$( r1, r2 )
\end{shortlist}

% // relative comparison:
\begin{shortlist}
  \item static HepDouble getTolerance(~)	\see{\ref{eq:epsildefR}}
  \item static HepDouble setTolerance( tol )
  \item bool isNear( r, epsilon )		\see{\ref{eq:nearrot}}
  \item HepDouble howNear( r ) 			\see{\ref{eq:nearrot}}
  \item HepDouble distance2( r )		\see{\ref{eq:dist2rot}}
\end{shortlist}

% // ordering comparison:
\begin{shortlist}
  \item r1 == r2 \/\/\/ r1 != r2
  \item r1 $>$ r2 \/\/\/ r1 $>=$ r2 \/\/\/ r1 $<$ r2 \/\/\/ r1 $<=$ r2 
		\see{\ref{eq:ordrot}}
\end{shortlist}

% // ---------- Apply rotations:
\begin{shortlist}
  \item Hep3Vector operator(~)~( const Hep3Vector \& v ) \see{\ref{eq:Rv}}
  \item Hep3Vector operator* ~ ( const Hep3Vector \& v ) \see{\ref{eq:Rv}}
  \item LorentzVector operator(~)~( const LorentzVector \& p ) \see{\ref{eq:Rv}}
  \item LorentzVector operator* ~ ( const LorentzVector \& p ) \see{\ref{eq:Rv}}
\end{shortlist}


\begin{shortlist}
  \item HepDouble norm2(~)		\see{\ref{eq:norm2rot}}
  \item HepDouble isIdentity(~)		

  \item ostream \& print ( ostream \& os )
  \item ostream \& operator$<<$( ostream \& os, const RotationInterface \& r )
  \item rectify(~)				\see{\ref{eq:rectRot}}

\end{shortlist}

\subsubsection{The Rotation Group}

The following methods use \Ro s as a group, that is, they invert, multiply, 
and so forth:

\begin{shortlist}
% // multiplication
  \item Hep3Rotation operator* ~ ( const Hep3Rotation \& r ) 
		\see{\ref{eq:opmulrot}}
  \item operator*= ~ ( const Hep3Rotation \& r ) 
		\see{\ref{eq:opstrot}}
  \item transform ~ ( const Hep3Rotation \& r ) 
		\see{\ref{eq:transrot}}
  \item RotateX (delta) \/\/\/ RotateY (delta) \/\/\/ RotateZ (delta) 
		\see{\ref{eq:xyzrot}}
  \item RotateAxes (newX, newY, newZ) 
		\see{\ref{eq:rotaxes}}

% // inversion:
  \item invert(~)
  \item HepRotation inverse(~)
  \item HepRotation inverseOf( r )


\end{shortlist}

\subsubsection{Axial Rotations}

There are threee specialized rotation classes, {\tt HepRotationX}, 
{\tt HepRotationZ}, and {\tt HepRotationZ}.
These use substantially less storage than the general \Ro, 
and for some methods it is quicker to work with a specialized axial rotation
rather than the general case.

All information which can be obtained from a general \Ro\ can be obtained 
from any of these specialized axial rotations.  
However, the set of methods which modify the rotations are very restricted
for the specialized cases:
\begin{shortlist}
% // supply angle of rotation(an identity rotation by default):
  \item RotationX(~)
  \item RotationX( delta )		\see{\ref{eq:rotX}}
  \item RotationX \& set( delta )	\see{\ref{eq:rotX}}
  \item RotationY(~)
  \item RotationY( delta )		\see{\ref{eq:rotY}}
  \item RotationY \& set( delta )	\see{\ref{eq:rotY}}
  \item RotationZ(~)
  \item RotationZ( delta )		\see{\ref{eq:rotZ}}
  \item RotationZ \& set( delta )	\see{\ref{eq:rotZ}}
\end{shortlist}

\subsection{\protect\Ros\ Class --- Derived from \Ro }

The \Ros\ classes (which also include {\tt RotationX},
{\tt RotationY}, and {\tt RotationZ}) provide backward compatibility 
with the original ZOOM PhysicsVectors package.  
These are simply typedefs the corresponding CLHEP classes, 
in the appropriate namespace.
This is because there were no features or constructors in the ZOOM 
product which were felt to be overkill in the CLHEP context.  

The {\tt Rotation.h} header in the ZOOM area also defines
{\tt ZMpvRep3x3}, {\tt ZMpvRep3x3}, and {\tt ZMpvRep3x3} which 
are typedefs for the corresponding CLHEP structs.

\subsection{\protect\LT\ Classes}
\label{ltmethods}

There are three sorts of Lorentz transformation objects suppoprted:  
General \LT s, pure Lorentz boosts {\tt HepBoost}, and pure boosts 
along axes {\tt HepBoostX}, {\tt HepBoostY}, {\tt HepBoostZ}.   

(Technically, ordinary \Ro s and axial rotations can also be considered
as Lorentz transformations, and indeed one of those classes can be used
wherever a general Lorentz transformation is called for.  The class
{\tt Hep4RotationInterface} represents the abstract concept.
But the rotation classes have been defined above, so we will restrict this 
section to discussing transformations involving the time component.)

Throughout this section, 
arguments named lt, lt1, lt2, etc., are of type \LT,
arguments named b, b1, b2, etc., are of type \LB, and
arguments named r, r1, r2, etc., are of type \Ro .
Arguments named R can be any sort of {\tt Hep4RotationInterface} including
\LT s, boosts, rotations, and axial boosts and rotations.
Also, row1, row2, row3, row4, col1, col2, col3, col4
will represent \LV\ arguments.

\subsubsection{Constructors and Accessors---HepLorentzRotation}

\begin{shortlist}
% // construct an identity transformation by default:
  \item HepLorentzRotation(~)

% // copy/assign 
  \item HepLorentzRotation ( lt )
  \item HepLorentzRotation ( r )
  \item HepLorentzRotation ( R )
  \item HepLorentzRotation \& operator=( lt )
  \item HepLorentzRotation \& operator=( r )
  \item HepLorentzRotation \& operator=( R )
  \item HepLorentzRotation \& set( lt )
  \item HepLorentzRotation \& set( r )
  \item HepLorentzRotation \& set( R )

% // supply boost

  \item HepLorentzRotation ( Hep3Vector boostVector )
  \item HepLorentzRotation ( HepBoost   boost )
  \item HepLorentzRotation ( boostX, boostY, boostZ )
  \item HepLorentzRotation \& set ( Hep3Vector boostVector )
  \item HepLorentzRotation \& set ( HepBoost   boost )
  \item HepLorentzRotation \& set ( boostX, boostY, boostZ )

% // supply R and B
  \item HepLorentzRotation ( b, r )			\see{\ref{eq:decomBR}}
  \item HepLorentzRotation \& set( b, r )		
  \item HepLorentzRotation ( r, b )			\see{\ref{eq:decomRB}}
  \item HepLorentzRotation \& set( b, r )		

% // supply LorentzVectors for the cols:
  \item HepLorentzRotation( col1, col2, col3, col4 )  
  \item HepLorentzRotation \& set( col1, col2, col3, col4 )  
  \item HepLorentzRotation \& setRows( row1, row2, row3, row4 )  
% // NOTE:	
% //		This constructor and set method will check that the
% //		cols form an orthonormal matrix, and adjust so that
% //		relation is as exact as possible.

% // supply HepRep4x4 structure:
  \item HepLorentzRotation( const HepRep4x4 \& rep )
  \item HepLorentzRotation \& set( const HepRep4x4 \& rep )

% // output
 \item print ( ostream \& os ) 

\end{shortlist}

\subsubsection{Constructors and Accessors---HepBoost}

\begin{shortlist}
  \item HepBoost(~)
  \item HepBoost( b )
  \item HepBoost \& set( b )
% // supply axis and beta;
  \item HepBoost ( const Hep3Vector \& direction, beta ) 
							\see{\ref{eq:boostform}}
  \item HepBoost \& set( const Hep3Vector \& direction, beta )

  \item HepBoost ( const Hep3Vector \& betaVector ) 
							\see{\ref{eq:boostform}}
  \item HepBoost \& set( const Hep3Vector \& betaVector )
  \item HepBoost ( betaX, betaY, betaZ ) 		\see{\ref{eq:boostform}}
  \item HepBoost \& set( betaX, betaY, betaZ ) 
  \item HepBoost( const HepRep4x4Symmetric \& rep )
  \item HepBoost \& set( const HepRep4x4Symmetric \& rep )

\subsubsection{Constructors and Accessors---Axial Boosts}
% // supply beta 
  \item HepBoostX(~)
  \item HepBoostX( beta )		\see{\ref{eq:boostx}}
  \item HepBoostX \& set( beta )	
  \item HepBoostY(~)
  \item HepBoostY( beta )		
  \item HepBoostY \& set( beta )	
  \item HepBoostZ(~)
  \item HepBoostZ( beta )		
  \item HepBoostZ \& set( beta )	
\end{shortlist}

\subsubsection{Components and Decomposition} 

\begin{shortlist}
  \item decompose(HepBoost \& b, HepRotation \& r)  	\see{\ref{eq:decomBR}}
  \item decompose(HepRotation \& r, HepBoost \& b)  	\see{\ref{eq:decomRB}}
%// for orthosymplectic Lorentz vectors
  \item col1(~) \/\/\/ col2(~) \/\/\/ col3(~) \/\/\/ col4(~) 
  \item row1(~) \/\/\/ row2(~) \/\/\/ row3(~) \/\/\/ row4(~) 
% // for individual elements:
  \item xx(~) \/\/\/ xy(~) \/\/\/ xz(~) \/\/\/ xt(~) 
  \item yx(~) \/\/\/ yy(~) \/\/\/ yz(~) \/\/\/ yt(~) 
  \item zx(~) \/\/\/ zy(~) \/\/\/ zz(~) \/\/\/ zt(~) 
  \item tx(~) \/\/\/ ty(~) \/\/\/ tz(~) \/\/\/ tt(~) 

% // for all 16 elements:
  \item HepRep4x4 rep4x4(~) 	
\end{shortlist}

\begin{shortlist}
  \item ostream \& operator$<<$( ostream \& os, const Hep4RotationInterface \& lt )
\end{shortlist}

\noindent
Also, components can be accessed by C-style and array-style subscripting:
\begin{shortlist}
  \item lt[i][j] \see{\ref{eq:ltsubscript}}
  \item lt(i,j)  \see{\ref{eq:ltsubscript}}
\end{shortlist}

The following are applicable to \LB\ but not to \LT:

\begin{shortlist}
  \item Hep3vector direction(~)	\/\/\/ beta(~) \/\/\/ gamma(~)
  \item Hep3Vector boostVector(~)
  \item HepRep4x4Symmetric rep4x4Symmetric(~) 
\end{shortlist}

\subsubsection{Application to 4-vectors}

% // ---------- Apply 
\begin{shortlist}
  \item LorentzVector operator*~( const LorentzVector \& w ) 
  \item LorentzVector operator(~)~( const LorentzVector \& w ) 
\end{shortlist}

\subsubsection{Comparisons and Nearness}

% // intolerant comparison:
\begin{shortlist}
  \item lt1 == lt2 \/\/\/ lt1 != lt2 		\see{\ref{eq:ltexact}}
  \item lt1 $>$ lt2 \/\/\/ lt1 $>=$ lt2 \/\/\/ lt1 $<$ lt2 \/\/\/ lt1 $<=$ lt2
						\see{\ref{eq:ltorder}}
  \item isIdentity()
\end{shortlist}


% // tolerant comparison:
\begin{shortlist}
  \item getTolerance(~)	\see{\ref{eq:epsildefR}}
  \item setTolerance( tol )
  \item int compare(lt)				\see{\ref{eq:ltorder}}
  \item bool isNear( lt, epsilon )		\see{\ref{eq:nearboost},
						     \ref{eq:isnearLT}}
  \item double distance2( lt ) 			\see{\ref{eq:hownearboost}, 
						     \ref{eq:isnearLT}}
  \item double howNear( lt ) 			\see{\ref{eq:hownearboost}, 
						     \ref{eq:isnearLT}}
  \item double norm2()				\see{\ref{eq:boostnorm2},
						     \ref{eq:ltnorm2}}
\end{shortlist}

\subsubsection{Arithmetic in the Lorentz Group}

% // arithmetic:
\begin{shortlist}
  \item lt1 * lt2
  \item HepLorentzRotation \& operator\verb$*=$( lt )
  \item HepLorentzRotation \& operator\verb$*=$( b )
  \item HepLorentzRotation \& operator\verb$*=$( r )
  \item HepLorentzRotation \& transform ( lt )  	\see{\ref{eq:lttrans}}
\end{shortlist}

% // inversion:
\begin{shortlist}
  \item invert(~)
  \item HepLorentzRotation inverseOf( lt )
\end{shortlist}

% // boosts and rotations
\begin{shortlist}
  \item HepLorentzRotation \& rotate ( delta, axis ) 	\see{\ref{eq:ltrot}}
  \item HepLorentzRotation \& rotateX ( delta ) 
  \item HepLorentzRotation \& rotateY ( delta ) 
  \item HepLorentzRotation \& rotateZ ( delta ) 
  \item HepLorentzRotation \& boost ( betaX, betaY, betaZ) \see{\ref{eq:ltboost}}
  \item HepLorentzRotation \& boost ( v )		\see{\ref{eq:ltboost}}
  \item HepLorentzRotation \& boostX ( beta ) 
  \item HepLorentzRotation \& boostY ( beta ) 
  \item HepLorentzRotation \& boostZ ( beta ) 
\end{shortlist}

% // rectify
\begin{shortlist}
  \item rectify(~)					\see{\ref{eq:rectLT}}
\end{shortlist}

\subsubsection{Arithmetic on Boosts}

The pure boosts do not form a group, since the product of two 
boosts is a Lorentz transformation which in general involves a rotation.
The pure boosts along an axial direction do form groups.

\begin{shortlist}
  \item LorentzBoost inverseOf( b )
  \item LorentzBoostX inverseOf( LorentzBoostX bx )
  \item LorentzBoostY inverseOf( LorentzBoostY by )
  \item LorentzBoostZ inverseOf( LorentzBoostZ bz )
\end{shortlist}

\begin{shortlist}
  \item bx = bx1 * bx2
  \item by = by1 * by2
  \item bz = bz1 * bz2
\end{shortlist}

\subsection{\protect\LTs\ Class --- Derived from \LT }

The \LT\ classes provides backward compatibility 
with the original ZOOM PhysicsVectors package.  
It is defined in {\tt LorentzTransformation.h} in the ZOOM area, and
is a typedef for \LT, in the appropriate namespace.
This is because there were no features or constructors in the ZOOM 
product which were felt to be overkill in the CLHEP context.  

Similarly, that files establishes typedefs 
{\tt LorentzBoost} for {\tt HepBoost}, 
{\tt LorentzBoostX} for {\tt HepBoostX}, 
{\tt LorentzBoostY} for {\tt HepBoostY}, and  
{\tt LorentzBoostZ} for {\tt HepBoostZ}. 

Also, for any ZOOM users using {\tt LorentzTransformationInterface},
this is typedefed in {\tt LorentzTransformation.h} as 
{\tt Hep4RotationInterface}.

\newpage
\section{\protect\SV\ and \protect\SVz\ Classes}

\SV s may be expressed as Cartesian coordinates, Spherical coordinates,
or Cylindrical coordinates.

\begin{eqnarray}
  ( x, y, z ) \label{eq:cartesian}\\
  ( r, \theta, \phi ) \nonumber \\
  \left\{
  \begin{array}{r}
  x = r \sin \theta \cos \phi \\
  y = r \sin \theta \sin \phi \\
  z = r \cos \theta \label{eq:polar}
  \end{array}
  \right. \\
  ( \rho, \phi, z ) \nonumber \\
  \left\{
  \begin{array}{r}
  x = \rho \cos \phi \\
  y = \rho \sin \phi \\
  z = z \label{eq:cylindrical}
  \end{array}
  \right.
\end{eqnarray}

For Spherical coordinates one may optionally
specify the pseudorapidity $\eta$ instead of $\theta$.

\begin{eqnarray}
  \left( \rho, \phi, \eta = - \ln { \tan { \frac {\theta}{2} } } \right)
  \label{eq:spherical}
\end{eqnarray}

When accessing the angles in Sperical coordinates, the values obtained will
always be in the range  $0 \leq \theta \leq \pi$ and $-\pi < \phi \leq +\pi$. 


\subsection {Dot and Cross Products}

\noindent
Let $\vec{v}_{1}$ and $\vec{v}_{2}$ be \SV s.  Then:

\begin{eqnarray}
  \vec{v}_{1}.\mbox{dot} (\vec{v}_{2}) \equiv
    \vec{v}_{1} \cdot \vec{v}_{2} = \sum_{i} \vec{v}_{1i} \vec{v}_{2i}
    \label{eq:dot} \\
  \vec{v}_{1}.\mbox{cross} (\vec{v}_{2}) \equiv
    \vec{v}_{1} \times \vec{v}_{2} = \stackrel{\longrightarrow} 
	{ {\textstyle \left( 
		\sum_{jk} \epsilon_{ijk} \vec{v}_{1j} \vec{v}_{2k} \right) } }
    \label{eq:cross} \\
  \vec{v}_{1}.\mbox{diff2} (\vec{v}_{2}) =
    \left| \vec{v}_{1} - \vec{v}_{2} \right| ^ 2 \label{eq:diff2}
\end{eqnarray}
\noindent
Here, $\epsilon_{ijk}$ is the three-index anti-symmetric symbol.


\subsection {Near Equality and isOrthogonal/isParallel}

\noindent
We structure the definitions of near equality and orthogonal/parallel such that
they are commutative (order of vectors makes no difference), rotationally
invariant, and scale invariant (multiplying both vectors by the same non-zero
constant makes no difference).  They also match the definitions of relative
equality (or perpendicularity or parallelism) within $\epsilon$ for the case
where each vector is along or near an axis.  This fixes the definitions, up to
order $\epsilon$.

\noindent
Let the method {\tt isNear()} be represented by the symbol $\approx$,
and let $\vec{v}_{1}, \vec{v}_{2}$ be \SV s.
Then:

\begin{equation}
\label{vecisnear}
\vec{v}_{1} \approx \vec{v}_{2} \mbox{ if }
  \left| \vec{v}_{1} - \vec{v}_{2} \right| ^ 2
  \leq \epsilon^2 \vec{v}_{1} \cdot \vec{v}_{2}
  \label{eq:isNear}
\end{equation}

\noindent
However, if $\vec{v}_{1}$ and/or $\vec{v}_2$ is known to be a UnitVector
(designated as $\hat{u}_{1}$), this sets a meaningful scale---if the
vectors are nearly equal, they are both of magnitude near unity.
In that case a simpler absolute formula, which is which is equivalent
to order $\epsilon$ to the relative criterion \ref{vecisnear}, is used:

\begin{equation}
\hat{u}_{1} \approx \vec{v}_{2} \mbox{ if }
  \left| \hat{u}_{1} - \vec{v}_{2} \right| ^ 2 \leq \epsilon^2
\end{equation}

\noindent
Tests for {\tt v1.isParallel(v2)}
and {\tt v1.isOrthogonal(v2)} utilize the dot and
cross products:

\begin{eqnarray}
\vec{v}_{1} \parallel \vec{v}_{2} \mbox{ if }
  \left| \frac{\vec{v}_{1} \times \vec{v}_{2}}
  {\vec{v}_{1} \cdot  \vec{v}_{2}}  \right| ^2
  \le \epsilon^2
  \label{eq:isPar} \\
\vec{v}_{1} \perp \vec{v}_{2} \mbox{ if }
  \left| \frac{\vec{v}_{1} \cdot \vec{v}_{2}}
  {\vec{v}_{1} \times  \vec{v}_{2}}  \right| ^2
  \le \epsilon^2
  \label{eq:isOrtho}
\end{eqnarray}
\noindent
Care is taken to avoid taking products of more than two potentially large
quantities in evaluating these.  Thus these tests can be done on any vectors
which could safely be squared.

\noindent
$\epsilon$ is assumed to be small; in some cases, short cuts are taken
to determine the result without potentially generating large quantities.
These techniques are not necessarily faithful to the above formulae when
$\epsilon \ge 1$.

\noindent
The definition of {\tt v1.isParallel(v2)} is equivalent, to order $\epsilon$,
to a simple (but computationally more expensive) definition involving
normalizing the vectors:
\begin{displaymath}
  \vec{v}_{1} \parallel \vec{v}_{2} \mbox{ if }
  	\left| \hat{v}_{1} - \hat{v}_{2} \right| ^2  \le \epsilon^2
\end{displaymath}


\noindent
If one of the vectors is the zero vector, the above relations may be ambiguous
instead the following hold:
($\vec{v}$ here is any non-zero vector):

\begin{eqnarray}
  \vec{v} \approx \vec{0} \mbox{ iff } \vec{v} = \vec{0} \\
  \vec{v} \perp \vec{0} \mbox{ for all } \vec{v} \\
  \vec{v} \parallel \vec{0} \mbox{ iff } \vec{v} = \vec{0}
\end{eqnarray}

\noindent

The default tolerance (which may be modified by the class static method
{\tt setTolerance()}) for vectors and Lorentz vectors
is 100 times the double precision epsilon.
\begin{equation}
  \epsilon_{\mbox{default}} \approx 2.2 \cdot 10^{-14}
\label{eq:epsildef}
\end{equation}

\subsection {Measures of Near-ness}

Each boolean tolerance comparison method is accompanied by a method returning
the measure used to compare to the tolerance $\epsilon$.
The formulae can be deduced from those above:

\begin{eqnarray}
\vec{v}_{1} \mbox{.howNear} (\vec{v}_{2}) =
  \max \left( \sqrt{ \frac {\left| \vec{v}_{1} - \vec{v}_{2} \right| ^ 2}
  {\vec{v}_{1} \cdot \vec{v}_{2}} } , 1 \right)
  \label{eq:howNear} \\
\vec{v}_{1} \mbox{.howParallel} (\vec{v}_{2}) =
  \max \left( \left| \frac{\vec{v}_{1} \times \vec{v}_{2}}
  {\vec{v}_{1} \cdot  \vec{v}_{2}}  \right| , 1 \right)
  \label{eq:howPar} \\
\vec{v}_{1} \mbox{.howOrthogonal} (\vec{v}_{2}) =
  \max \left( \left| \frac{\vec{v}_{1} \cdot \vec{v}_{2}}
		    {\vec{v}_{1} \times  \vec{v}_{2}}  \right| , 1 \right)
  \label{eq:howOrtho}
\end{eqnarray}

\noindent
The above relative measures are limited to a maximum of 1; cases where
the denominator would be zero may safely be done without overflow.
(Of course, {\tt howParallel()} and {\tt howOrthogonal()} are close to
zero for nearly parallel and perpendicular vectors, respectively).

Note that since a UnitVector has a natural absolute scale, the
{\tt Unitvector::howNear()} method is absolute, not relative.
When a comparison method involves absolute tolerance, the measure returned
is not truncated at 1:

\begin{eqnarray}
\hat{u}_{1} \mbox{.howNear} (\vec{v}_{2}) =
  \vec{v}_{2} \mbox{.howNear} (\hat{u}_{1}) =
  \left| \hat{u}_{1} - \vec{v}_{2} \right|
  \label{eq:howNear:2}
\end{eqnarray}

In addition, we provide \verb$deltaR()$,
a measure of nearness useful in collider physics analysis.
It is defined by

\begin{equation}
\vec{v}_{1} \mbox{deltaR} (\vec{v}_{2}) =
  \sqrt{ (\Delta \phi)^2 + (\Delta \eta)^2) } =
  \sqrt{ \left( \vec{v}_{1}\mbox{.phi} - \vec{v}_{2}\mbox{.phi} \right)^2 +
  \left( \vec{v}_{1}\mbox{.eta} - \vec{v}_{1}\mbox{.eta}  \right)^2 }
  \label{eq:deltaR}
\end{equation}
\noindent
where of course the angular $\phi$ difference is corrected to lie in the range
$(-\pi, \pi]$ (the {\tt deltaPhi()} method is used).

When one vector or the other is zero,

\begin{eqnarray}
\vec{v} \mbox{.howNear} (\vec{0}) =
  \vec{0} \mbox{.howNear} (\vec{v}) = 1
  \label{eq:howNear:3}
  \\
\vec{v} \mbox{.howParallel} (\vec{0}) =
  \vec{0} \mbox{.howParallel} (\vec{v}) = 1
  \label{eq:howPar:2}
  \\
\vec{v} \mbox{.howOrthogonal} (\vec{0}) =
  \vec{0} \mbox{.howOrthogonal} (\vec{v}) = 0
  \label{eq:howOrtho:2}
  \\
\vec{v} \mbox{.deltaR} (\vec{0}) = \vec{0} \mbox{.deltaR} (\vec{v}) =
  \left| \Delta \eta \right| =
  \left| \vec{v}\mbox{.eta()} \right|
  \label{eq:deltaR:2}
\end{eqnarray}

When both vectors are zero, all these measures will return zero.

\subsubsection{Ordering Comparisons for \protect\SV s}

The comparison operators \verb$ ( >, >=, <, <= )$ for \SV\ (and for
\UV) use a ``dictionary ordering'',
comparing first the Z, then the Y, then the
X components:
\begin{eqnarray}
  \vec{v}_1 > \vec{v}_2 \mbox{ if }	\nonumber \\
	z_1 > z_2 \mbox { or } \nonumber \\
	\left[
	z_1 = z_2 \mbox { and }
	y_1 > y_2 \right] \mbox { or } \nonumber \\
	\left[
	z_1 = z_2 \mbox { and }
	y_1 = y_2 \mbox { and }
	x_1 > x_2 \right]
  \label{eq:compSV}
\end{eqnarray}


\subsection{Intrinsic Properties and Relativistic Quantities}

A \SV\ does not have much in the way of intrinsic properties---just its
magnitude.
We can also talk about the pseudorapidity, which depends only on the angle
against the Z axis.

\begin{eqnarray}
  \vec{v1}\mbox{.mag() } = \sqrt { \vec{v}_{1} \cdot \vec{v}_{1} }
    \label{eq:mag} \\
  \vec{v1}\mbox{.mag2() } = \vec{v}_{1} \cdot \vec{v}_{1}
    \label{eq:mag2} \\
  \vec{v1}\mbox{.eta() } = 	-\ln \tan \frac {\theta_{\vec{v}_1,\hat{z}}}{2}
    = -\ln \tan \frac {\hat{v}_1 \cdot \hat{z}}{2}
    \label{eq:eta}
\end{eqnarray}

Another intrinsic is the unit vector in the direction of $\vec{v}$:
\begin{eqnarray}
  \vec{v}\mbox{.unit() } = \frac{\vec{v}}{|v|}
    \label{eq:svunit} 
\end{eqnarray}

A somewhat contrived intrinsic property, useful for Geant4, is a special 
vector orthognal to $\vec{v}$, lying in a plane defined by two coordinate 
axes.
The plane is chosen so as to supress the smallest component of $\vec{v}$.
\begin{eqnarray}
  \min( v_x, v_y, v_z ) = v_z \Longrightarrow 
		\vec{v}\mbox{.orthogonal() } = \left\{ v_y, -v_x, 0 \right\}
    \label{eq:orthogonal} \\
  \min( v_x, v_y, v_z ) = v_y \Longrightarrow 
		\vec{v}\mbox{.orthogonal() } = \left\{ -v_z, 0, v_x \right\}
    \nonumber \\
  \min( v_x, v_y, v_z ) = v_z \Longrightarrow 
		\vec{v}\mbox{.orthogonal() } = \left\{ 0, v_z, -v_y \right\}
    \nonumber 
\end{eqnarray}
(In the case of equal components, $v_z$ is considered smallest, then $v_y$.)


\noindent
A \SV\ of length less than 1 may be considered as defining a Lorentz boost;
in that sense, we can discuss $\beta$ and $\gamma$ of the \SV, and the rapidity
associated with that boost.

\begin{eqnarray}
  \vec{v1}\mbox{.beta() } = \vec{v1}\mbox{ .mag() } = \beta
    \label{eq:mag:2} \label{eq:beta} \\
  \vec{v1}\mbox{.gamma() } = \frac{1} {\sqrt {1-\beta^2 } } = \gamma
    \label{eq:gamma} \\
  \vec{v1}\mbox{.rapidity() } = \tanh^{-1} (\vec{v}_{1} \cdot \hat{z})
    \label{eq:rap} \\
  \vec{v1}\mbox{.coLinearRapidity() } = \tanh^{-1} \beta
    = \tanh^{-1} (\vec{v}_{1} \cdot \hat{v}_1)
    \label{eq:coLinRap}
\end{eqnarray}

The rapidity and pseudorapidity are discussed further in
section \S{\ref{rapidity}}.

\subsection{Properties Involving Vectors and Directions}

Let a reference direction be represented by a unit vector $\hat{u}$ in that
direction.
In all the following methods, the reference direction may be
omitted, defaulting to $\hat{\bf z}$.
And in these methods, a {\em non-zero} second vector may be
substituted for $\hat{u}$; the unit vector in the direction of $\vec{v}_2$
will be used in that case.
Then the following definitions of methods relative to the reference direction
apply:

\begin{eqnarray}
  \vec{v}\mbox{.angle} (\hat{u}) =
    \theta_{\vec{v},\hat{u}} =
    \cos^{-1} \left( \frac{ \vec{v} \cdot \hat{u} }
    { \left| \vec{v} \right| } \right)
    \label{eq:angle} \label{eq:theta} \\
  \vec{v}\mbox{.cosTheta} (\hat{u}) =
    \cos \theta_{\vec{v},\hat{u}}
    \label{eq:cosTheta} \\
  \vec{v}\mbox{.cos2Theta} (\hat{u}) =
    \cos^2 \theta_{\vec{v},\hat{u}}
    \label{eq:cos2Theta} \\
  \vec{v}\mbox{.eta} (\hat{u}) =
    -\ln \tan \frac {\theta_{\vec{v},\hat{u}}}{2}
    \label{eq:eta:2} \\
  \vec{v}\mbox{.rapidity} (\hat{u}) =
    \tanh^{-1} (\vec{v}_{1} \cdot \hat{u})
    \label{eq:rap:2} \\
  \vec{v}\mbox{.perp} (\hat{u}) =
    \left| \vec{v} - (\vec{v} \cdot \hat{u}) \hat{u} \right|
    \label{eq:perp} \\
  \vec{v}\mbox{.perp2} (\hat{u}) =
    \left| \vec{v} - (\vec{v} \cdot \hat{u}) \hat{u} \right| ^2
    \label{eq:perp2} \\
  \vec{v}\mbox{.perpPart} (\hat{u}) =
    \vec{v} -
    \hat{u} \cos \theta_{\vec{v},\hat{u}}
    \left| \vec{v} \right| =
    \vec{v} - (\vec{v} \cdot \hat{u}) \hat{u}
    \label{eq:perpPart} \\
  \vec{v}\mbox{.project} (\hat{u}) =
    \hat{u} \cos \theta_{\vec{v},\hat{u}}
    \left| \vec{v} \right| =
    (\vec{v} \cdot \hat{u}) \hat{u}
    \label{eq:project} \\
  \vec{v}\mbox{.polarAngle} (\vec{v_2})
    \equiv \vec{v}\mbox{.polarAngle} (\vec{v_2}, \hat{z}) =
    \vec{v_2}\mbox{.theta()} - \vec{v}\mbox{.theta()}
    \label{eq:polarA} \\
  \vec{v}\mbox{.polarEta} (\vec{v_2})
    \equiv \vec{v}\mbox{.polarEta} (\vec{v_2}, \hat{z}) =
    \vec{v_2}\mbox{.eta()} - \vec{v}\mbox{.eta()}
    \label{eq:polarEta} \\
  \vec{v}\mbox{.polarAngle} (\vec{v_2}, \hat{u}) =
    \vec{v_2}\mbox{.eta}(\hat{u}) - \vec{v}\mbox{.eta}(\hat{u})
    \label{eq:polarA:2} \\
  \vec{v}\mbox{.azimAngle} (\vec{v_2})
    \equiv \vec{v}\mbox{.azimAngle} (\vec{v_2}, \hat{z}) =
    \vec{v_2}\mbox{.phi()} - \vec{v}\mbox{.phi()} ^*
    \label{eq:azim} \\
  \vec{v}\mbox{.deltaPhi} (\vec{v_2})
    \equiv \vec{v}\mbox{.azimAngle} (\vec{v_2}) 
    \label{eq:deltaPhi} \\
  \vec{v}\mbox{.azimAngle} (\vec{v_2}, \hat{u}) =
    \theta_{\vec{v_2}\mbox{.perpPart}(\hat{u}),
    \vec{v}\mbox{.perpPart}(\hat{u})}
    \mbox{ sign} \left( \hat{u} \cdot (\vec{v} \times \vec{v_2}) \right)
    \label{eq:azim:2}
\end{eqnarray}

\noindent

* Equation (\ref{eq:azim}) is not quite definitive:  
The azimuthal angle between two vectors (or delta phi)
will always be translated into an 
equivalent angle in the range $(-\pi,\pi]$.

The azimuthal angle between two vectors with respect to a reference direction,
as shown in equation (\ref{eq:azim:2}) above, is found by
projecting both vectors into the plane defined by the reference direction,
and taking the angle between those projections, in the clockwise sense about
the reference axis.  Again, this will be in the range $(-\pi,\pi]$.

\subsection{Direct Vector Rotations}
\label{rotations}

Direct vector rotations are methods of \SV\ or \LV\ which
modify the vector being acted
upon---{\tt v.rotate}$(\phi, \theta, \psi)$---or
global functions which form a new
vector---{\tt rotationOf}$(\vec{v}, \phi, \theta, \psi)$.

\noindent
Rotations about the X, Y, or Z axis are defined in the counter-clockwise
sense.  Thus for rotations about the Z axis, if $\vec{v}$ has representation
in polar coordinates $( v_r, v_\theta, v_\phi )$
\begin{equation}
  \vec{v}.\mbox{rotateZ} ( \delta ) \mbox{ is equivalent to }
  \vec{v}_\phi \Longrightarrow \vec{v}_\phi + \delta
    \label{eq:rotZ:2}
\end{equation}
\noindent
The axis rotations are implemented taking advantage of their
simple form.  When $\vec{v} = (x, y, z)$ is rotated by angle $\delta$,
\begin{eqnarray}
  \vec{v}.\mbox{rotateZ} (\delta) \Longrightarrow
    ( x \cos\delta - y \sin\delta, x \sin\delta + y \cos\delta, z )
    \label{eq:rotZ} \\
  \vec{v}.\mbox{rotateY} (\delta) \Longrightarrow
    ( z \sin\delta + x \cos\delta, y, z \cos\delta - x \sin\delta )
    \label{eq:rotY} \\
  \vec{v}.\mbox{rotateX} (\delta) \Longrightarrow
    ( x, y \cos\delta - z \sin\delta, y \sin\delta + z \cos\delta )
    \label{eq:rotX}
\end{eqnarray}
\noindent
More general rotations may be expressed in terms of
an angle $\delta$ (counter-clockwise) about an axis given
as a \UV\ $\hat{u}$, or in terms of Euler Angles
$(\phi, \theta, \psi)$:

\[  \vec{v}.\mbox{rotate}(\hat{u},\delta) \Longrightarrow \]
\begin{equation}
\label{eq:axisrot}
\left(
\begin{array}{ccc}
\cos \delta + (1 - \cos \delta ) u_x^2 &
(1 - \cos \delta ) u_x u_y - \sin \delta u_z &
(1 - \cos \delta ) u_x u_z + \sin \delta u_y \\
(1 - \cos \delta ) u_y u_x + \sin \delta u_z &
\cos \delta + (1 - \cos \delta ) u_y^2 &
(1 - \cos \delta ) u_y u_z - \sin \delta u_x \\
(1 - \cos \delta ) u_z u_x - \sin \delta u_y &
(1 - \cos \delta ) u_z u_y + \sin \delta u_x &
\cos \delta + (1 - \cos \delta ) u_z^2
\end{array}
\right)
\left(
\begin{array}{c}
v_x\\
v_y\\
v_z
\end{array}
\right)
\end{equation}

\[  \vec{v}.\mbox{rotate}(\phi, \theta, \psi) \Longrightarrow  \]
\begin{equation}
\label{eq:eulerrot}
\left(
\begin{array}{ccc}
\cos \psi \cos \phi - \sin \psi \cos \theta \sin \phi &
\cos \psi \sin \phi + \sin \psi \cos \theta \cos \phi &
\sin \psi \sin \theta \\
- \sin \psi \cos \phi - \cos \psi \cos \theta \sin \phi &
- \sin \psi \sin \phi + \cos \psi \cos \theta \cos \phi &
\cos \psi \sin \theta \\
\sin \theta \sin \phi &
- \sin \theta \cos \phi &
\cos \theta
\end{array}
\right)
\left(
\begin{array}{c}
v_x\\
v_y\\
v_z
\end{array}
\right)
\end{equation}
\noindent
The Euler angles definition matches that found in found in
{\em Classical Mechanics} (Goldstein), page 109.
This treats the Euler angles as a sequence of counter-clockwise {\bf passive}
rotations;
that is, the vector remains fixed while the coordinate axes are rotated---new
vector components are computed in new coordinate frame.
It is unnatural (though possible) to view an Euler angles transformation as
as sequence of active rotations.

HEP computations ordinarily use the active rotation viewpoint.
Therefore, rotations about an axis imply {\bf active} counter-clockwise
rotation in this package. 

Consequently, a rotation by angle $\delta$ around the X axis is
equivalent to a rotation with Euler angles
$(\phi=\psi=0, \mbox{ } \theta = - \delta)$
and a rotation about the Z axis is
equivalent to a rotation with Euler angles
$(\theta = 0, \mbox{ } \phi=\psi= - \delta/2)$.

\subsubsection{RotateUz}

Another way to specify a direct rotation is via {\tt v.rotateUz(u)}
where u is required to be a unit \SV .
This rotates the reference frame such that the original Z-axis will lie 
in the direction of $\hat{u}$.  Many rotations would accomplish this; the
one selected uses $u$ as its third column and is given by:
\[  \vec{v}.\mbox{rotateUz}(u_x, u_y, u_z)\Longrightarrow  \]
\begin{equation}
\label{eq:rotUz}
\left(
\begin{array}{ccc}
u_x u_z / u_\perp & - u_y / u_\perp & u_x \\
u_y u_z / u_\perp &   u_x / u_\perp & u_y \\
- u_\perp         &      0          & u_z
\end{array}
\right)
\left(
\begin{array}{c}
v_x\\
v_y\\
v_z
\end{array}
\right)
\end{equation}
\noindent
Here, $u_\perp \equiv \sqrt{u_x^2 + u_y^2}$.  Using $u$ as the third column of 
the rotation removes the ambiguity except if $u$ is parallel to $\hat{z}$.
In that case, if $u = \hat{z}$ the vector $\vec{v}$ is left untouched, 
while if 
$u = - \hat{z}$,
If u is $-\hat{z}$, $\vec{v}$ is rotated by 180 degrees about the Y axis.

\subsubsection{Applying \protect\Ro s to \protect\SV s}

In CLHEP, the \SV\ class is aware of the existence of the \Ro\ class.  
This is reflected in two routines to apply a \Ro\ to the \SV :

\begin{equation}
\label{eq:opstareq}
\left.
\begin{array} {r}
\vec{v} \mbox{ *= } R \\
\vec{v} \mbox{.transform} (R) 
\end{array}
\right\}
\Longleftrightarrow
\vec{v} \leftarrow R \vec{v}
\end{equation}
\noindent
Notice that these are identical.
In contrast to the usual {\tt operator *=} semantics, 
{\tt v *= R } {\it left} multiplies the matrix representing {\tt v} 
by the matrix representing {\tt R}.


\subsection{Overflow for Large Vectors}

When vector components are near the limits of floating point representation,
there are cases where operations have mathematical results which can be
represented, but intermediate steps give too large a result.  An extreme
example is that testing whether two vectors are nearly orthogonal should give
a result of type \verb$bool$, yet the intermediate steps may involve a dot
product adding three huge terms.

\noindent
Although each of the vector operations described above can be performed
protecting against overflow (by judicious re-scaling) this generally leads
to unacceptable inefficiency in the overwhelming majority of cases where the
vectors are not so large.  The compromise used in this package is:

\begin{itemize}
\item All vectors are assumed to be ``squarable,'' that is, the algorithms
may freely take a dot product of a vector with itself.  For \verb$double$
numbers, this implies that components are limited to about $10^{153}$
in magnitude.
\item Care is taken that any operation, applied to squarable vectors, gives
the proper result.  This implies that we never take products of more than two
powers of components without checking for size and potentially re-scaling.
In particular, {\tt isParallel()} and {\tt isOrthogonal()} do extra work 
to avoid trouble when vectors have components on the order of $10^{76}$ to
$10^{152}$. 
\end{itemize}

\section{\protect\LV\ Class}

We always take the time component to be the `4' index, and $c = 1$.
For these equations, let the sense of the metric be $ {\cal M} = \pm 1$ and
the metric be represented as $g_{ij}$ where $g_{44} = {\cal M}$,
$g_{ii} = -{\cal M}$, and all other $g_{ij} = 0$.

\noindent
Let ${\bf w}_{1}$ and ${\bf w}_{2}$ be \LV s.
Then ${\bf w}_{1}$.dot(${\bf w}_{2}$) is defined by:
\begin{equation}
\label{eq:wdot}
  {\bf w}_{1} \cdot {\bf w}_{2} = \sum_{ij} g{_ij}
{\bf w}_{1}^{i} {\bf w}_{2}^{j} \\
\end{equation}
\noindent
The sign of this dot product is dependent on $\cal M$.

For the remainder of these definitions we will take the metric to be
(-- -- -- +) and point out any definitions which change sign when the
(+ + + --) metric is chosen.


\subsection{Combinations and Properties of \protect\LV s}

The dot product, and Lorentz-invariant magnitude squared and
squared norm of the difference between two 4-vectors, are metric-dependent.

Let $w_i = ( \vec{v}_i, t_i )$:

\begin{eqnarray}
\label{eq:wdot:2}
  w_1\mbox{.dot}(w_2) = w_1 \cdot w_2 = t_1 t_2 - \vec{v}_1 \cdot \vec{v}_2 \\
\label{eq:wmag2}
  w_1\mbox{.mag2}() = w_1 \cdot w_1 = t_1^2 - |\vec{v}_1|^2 \\
\label{eq:wdiff2}
  w_1\mbox{.diff2}(w_2) = (w_1-w_2) \cdot (w_1-w_2) =
	(t_1 - t_2)^2 -   \left| \vec{v}_1 - \vec{v}_2 \right| ^2 \\
\label{eq:wmag}
w_1\mbox{.mag(~)} = w_1\mbox{.m(~)} = 
	\mbox{sign}(t_1^2 - \vec{v}_1^2) 
		\sqrt{\left|t_1^2 - \vec{v}_1^2\right|} 
\end{eqnarray}

The Euclidean-norm, and Euclidean-norm difference squared, are given by
\begin{eqnarray}
\label{eq:wENorm2}
  w_1\mbox{.EuclideanNorm2}() = t_1^2 + |\vec{v}_1|^2 \\
\label{eq:wENorm}
  w_1\mbox{.EuclideanNorm}() = \sqrt{t_1^2 + |\vec{v}_1|^2} \\
\label{eq:wdelta2E}
  w_1\mbox{.delta2Euclidean}(w_2) = t_1 t_2 + \vec{v}_1 \cdot \vec{v}_2
\end{eqnarray}

It is convenient to have methods returning $t \pm z$; for completeness
we also provide the plus() and minus() methods relative to an arbitrary
direction $\hat{u}$:

\begin{eqnarray}
\label{eq:wplus}
  w_1\mbox{.plus}() = t_1 + z_1 \\
\label{eq:wminus}
  w_1\mbox{.minus}() = t_1 - z_1 \\
\label{eq:wplus:2}
  w_1\mbox{.plus}(\hat{u}) = t_1 + \vec{v}_1 \cdot \hat{u} \\
\label{eq:wminus:2}
  w_1\mbox{.minus}(\hat{u}) = t_1 - \vec{v}_1 \cdot \hat{u}
\end{eqnarray}

\subsection{Kinematics of \protect\LV s}

The rest mass and its square are independent of metric.
Note that {\tt restMass2()} differs from {\tt mag2()} in that no matter
which metric is selected, {\tt restMass2()} remains $t^2-v^2$.
The sign of the
rest mass is set to match the time component; thus the rest mass of
$(0,0,0,-m)$ will return as $-m$.

The method {\tt rest4Vector()} will return a 4-vector equal to this vector
in its rest frame.

\begin{eqnarray}
\label{eq:wrestM2}
  p\mbox{.restMass2}() = p\mbox{.invariantMass2}() = E^2 - |\vec{p}|^2 \\
\label{eq:wrestM}
  p\mbox{.restMass}() = p\mbox{.invariantMass}() =
	\sqrt {E^2 - |\vec{p}|^2} \times \mbox{sign}(t_1) \\
\label{eq:wrest4V}
  p\mbox{.rest4Vector}() =  \left( 0, 0, 0, p\mbox{.restMass}() \right)
\end{eqnarray}
\noindent
Taking the rest mass of a spacelike 4-vector will ZMthrow the exception
{\tt ZMxpvSpacelike}.

\noindent
The boost which if applied to {\tt w.rest4Vector()} would give the result
{\tt w} is {\tt w.boostVector()}.  A pure boost can be expressed as a \SV:
\begin{eqnarray}
\label{boostvector}
  w_1\mbox{.boostVector}() =  \frac{\vec{v}_1}{t_1} \\
  \left(w_1\mbox{.rest4Vector}()\right)\mbox{.boosted}
  		\left(w_1.\mbox{.boostVector}() \right) \equiv w_1 \nonumber
\end{eqnarray}
\noindent
The boostVector for a zero 4-vector will return as zero.
{\tt boostVector()}
will return $v/t$ even if the 4-vector is spacelike, but will ZMthrow a
{\tt ZMxpvTachyonic} error.
If $ t=0 $ it will throw {\tt ZMxpvInfiniteVector} and do the divisions,
returning an infinite vector if ignored.

Beta and gamma refer to this boost vector:
\begin{eqnarray}
\label{eq:wbeta}
  w_1\mbox{.beta}() = \beta = \left| w_1\mbox{.boostVector}() \right |
  = \frac{\left| \vec{v}_1 \right|} {| t_1 |} \\
\label{eq:wgamma}
  w_1\mbox{.gamma}() = \gamma = \frac{1}{\sqrt{1-\beta^2}}
\end{eqnarray}

Psuedorapidity and rapidity are discussed below (\S\ref{rapidity}):

\begin{eqnarray}
\label{eq:weta}
  w_1\mbox{.eta()} = - \ln \tan \frac{\theta}{2} \\
\label{eq:weta:2}
  w_1\mbox{.eta(u)} = - \ln \tan \frac{\hat{p} \cdot \hat{u}}{2} \\
\label{eq:wrapid}
  w_1\mbox{.rapidity() }
	= \frac{1}{2} \ln \left( \frac{E + p_z}{E - p_z}    \right)
	= \tanh^{-1} \frac {z}{t} \\
\label{eq:wrapid:2}
  w_1\mbox{.rapidity(u) }
	= \frac{1}{2} \ln \left( \frac{E + \vec{p} \cdot \hat{u}}
				      {E - \vec{p} \cdot \hat{u}} \right)
	= \tanh^{-1} \frac {\vec{v} \cdot \hat{u}} {t} \\
\label{eq:wcoLinRap}
  w_1\mbox{.coLinearRapidity() }
	= \frac{1}{2} \ln \left( \frac{E + |p|}{E - |p|}    \right)
	= \tanh^{-1} \frac {|v|}{t}
\end{eqnarray}

\noindent
The ``transverse mass'' is found by neglecting the x- and
y-components of the 4-vector.  This is the square root of the 
sum of the rest mass squared and the transverse momentum squared:
\begin{eqnarray}
\label{eq:wmt2}
  p\mbox{.mt2}() = E^2 - p_z^2 \\
\label{eq:wmt}
  p\mbox{.mt}() = \sqrt { \left| E^2 - |\vec{p}|^2 \right| } 
			\times \mbox{sign}(E^2 - |\vec{p}|^2) 
\end{eqnarray}
\noindent  
Note that $m_t \ge m$.  {\it Warning:} Although this definition for $m_t$
matches that of equation (34.36) in the Review of Particle Physics and this
definition has always been in CLHEP, some experimenters have indicated that 
various experiments may use different definitions, which are of more use to
their applications.  

\noindent
The ``transverse energy'' is defined as $E \sin \theta$.
This quantity is invariant, to order $m/E$, under boosts in the Z direction.
It is most easily expressed in terms of the energy, momentum, and 
transverse momentum:
\begin{eqnarray}
\label{eq:wet2}
  p\mbox{.et2}() = \frac {E^2 p_\perp^2}{|p|^2} \\
\label{eq:wet}
  p\mbox{.et}() = \sqrt { \left| \frac {E^2 p_\perp^2}{|p|^2} \right| } 
			\times \mbox{sign}(E)
\end{eqnarray}

\noindent
For completeness, the transverse mass and energy are also defined with respect 
to a direction specified by a \SV $\vec{v}$:
\begin{eqnarray}
  p\mbox{.mt2}(\vec{v}) = E^2 - ( \vec{p} \cdot \hat{v} )^2   \\
  p\mbox{.mt}(\vec{v}) = \sqrt {\left| E^2 - (\vec{p} \cdot \hat{v})^2\right|}
			\times \mbox{sign}(E^2 - ( \vec{p} \cdot \hat{v} )^2 )
			\\
  p\mbox{.et2}(\vec{v}) = \frac {E^2 p.\mbox{perp}(\hat{v})^2} {|p|^2} \\
  p\mbox{.et}(\vec{v}) = \sqrt { \left| \frac {E^2 p.\mbox{perp}(\hat{v})^2}
			{|p|^2} \right| } 
			\times \mbox{sign}(E)
\end{eqnarray}





\subsection{Invariant Mass and the Center-of-Mass Frame}

The invariant mass of a pair of \LV s is given by:

\begin{eqnarray}
\label{eq:winvMass2}
  w_1\mbox{.invariantMass2}(w_2) =
	\left(t_1+t_2\right)^2 - \left| \vec{v}_1 -  \vec{v}_2 \right| ^2 \\
\label{eq:winvMass}
  w_1\mbox{.invariantMass}(w_2) =
	\left(t_1+t_2\right)^2 - \left| \vec{v}_1 -  \vec{v}_2 \right| ^2
	\times \mbox{sign}(t_1 + t_2)
\end{eqnarray}

The boost necessary top bring a pair of vectors into their Center-of-Mass
frame is given by

\begin{eqnarray}
\label{eq:wfindBoost}
  w_1\mbox{.findBoostToCM}(w_2) = - \frac{\vec{v}_1 + \vec{v}_2}{t_1+t_2}
\end{eqnarray}
\noindent
If the sum of the two 4-vectors is spacelike, this makes analytic sense but
is physically meaningless; a {\tt ZMxpvTachyonic} error will be ZMthrown.
If the sum of the time components is zero, a
{\tt ZMxpvInfiniteVector} error will be ZMthrown.

\subsection{Various Forms of Masses and Magnitudes}

The \LV\ class combines the features of the CLHEP and ZOOM 4-vectors.
Each of these deal with several concepts related to the magnitude or
``mass'' associated with the 4-vector.  

This is further complicated by the possibility that the metric, 
normally taken to be (-- -- -- +) which we designate as $\cal M$ $= +1$,
can be set to (+ + + --) which we will designate as $\cal M$ $= -1$. 
So some of the definitions below will involve $\cal M$.
In the CLHEP original package, of course, $\cal M$ would always be $+1$.

These methods are defined above, but perhaps it will be helpful to 
provide them all in one place.
In the below definitions, since we are conceptually dealing with 
energy-momentum 4-vectors, we will use $(\vec{p},e)$ for the 4-vector 
components.

%			orig PV		 CLHEP			Merge
%mag2(~)			M * (t^2-v^2)	(t^2-v^2)		PV
%m2(~)			---		(t^2-v^2)		CLHEP
%mag(~)			---		sign(m2)*sqrt|m2|	CLHEP
%m(~)			---		sign(m2)*sqrt|m2|	CLHEP
%mt2(~)			---		e^2 - pz^2		CLHEP
%mt(~)			---		sign(mt2)*sqrt|mt2|	CLHEP
%w.dot(w)		M * (t^2-v^2)	(t^2-v^2)		PV
%w.invariantMass2(~)	---		---			(t^2-v^2)
%w.invariantMass(~)	---		---		sign(t)*sqrt(t^2-v^2)
%restMass2(~)		(t^2-v^2)	---			(t^2-v^2)
%restMass(~)		sign(t)*sqrt(t^2-v^2),# ---	
%					sign(t)*sign(t^2-v^2)*sqrt|t^2-v^2|

\begin{eqnarray}
w\mbox{.mag2()} = w\mbox{.dot(w)} = {\cal M} (E^2 - \vec{p}^2) 		\\
w\mbox{.m2(~)} = E^2 - \vec{p}^2 					\\
w\mbox{.mag(~)} = w\mbox{.m(~)} = 
	\mbox{sign}(E^2 - \vec{p}^2) \sqrt{\left|E^2 - |\vec{p}|^2\right|} \\
w\mbox{.invariantMass2(~)} = w\mbox{.restMass2(~)} = E^2 - |\vec{p}|^2 	\\
w\mbox{.w.invariantMass(~)} = w\mbox{.restMass(~)} =
	\mbox{sign}(E) \sqrt{E^2 - |\vec{p}|^2} \\  
w\mbox{.mt2(~)} = E^2 - p_z^2 	\\
w\mbox{.mt(~)} = 
	\mbox{sign}(E^2 - p_z^2) \sqrt{\left|E^2 - p_z^2\right|} \\
w\mbox{.et2}() = \frac {E^2 p_\perp^2}{|p|^2} \\
w\mbox{.et}() = \sqrt { \left| \frac {E^2 p_\perp^2}{|p|^2} \right| } 
			\times \mbox{sign}(E)
\end{eqnarray}
Thus a tachyonic particle (for which $t^2-v^2 < 0$) is assigned a 
negative mass m(), but a positive restMass().


\subsection{Direct \protect\LV\ Boosts and Rotations}

Direct boosts and rotations are methods of \LV\ which
modify the 4-vector being acted
upon--- {\it e.g.}, {\tt w.boost}$(\hat{u}, \beta)$---or
global functions which form a new
vector--- {\it e.g.}, {\tt boostOf}$(w, \hat{u}, \beta)$.

Rotations act in the obvious manner, affecting only the $\vec{v}$ component of
the 4-vector---see \S\ref{rotations}.

In analogy with our ``active'' rotation viewpoint, boosts are treated as
``active'' transformations rather than transformations of the coordinate system.
That is, if you take a 4-vector at rest, with positive mass ($t$),
and boost it by a positive amount in the X direction, the resulting 4-vector
will have positive $x$.

Boosts along the X, Y, or Z axis are simpler than the general case.
Let $w = (\vec{v}, t) = (x, y, z, t)$:

\begin{eqnarray}
\label{eq:wbX}
  w.\mbox{boostX} (\beta) \Longrightarrow
    ( \gamma x + \beta \gamma t, y, z, \gamma t + \beta \gamma x ) \\
\label{eq:wbY}
  w.\mbox{boostY} (\beta) \Longrightarrow
    ( x, \gamma y + \beta \gamma t, z, \gamma t + \beta \gamma y ) \\
\label{eq:wbZ}
  w.\mbox{boostZ} (\beta) \Longrightarrow
    ( x, y, \gamma z + \beta \gamma t, \gamma t + \beta \gamma z ) \\
  \gamma \equiv \frac{1}{\sqrt{1-\beta^2}} \nonumber
\end{eqnarray}


More general rotations boosts may be expressed in terms of
$\beta$ along an axis given as a \SV\ $\hat{u}$ (which will be normalized),
or in terms of a \SV\ boost $\vec{\beta}$, which must obey $|\vec{\beta}|<1$.
(Boosts beyond the speed of light ZMthrow a
{\tt ZMxpvTachyonic} error, and leave the 4-vector unchanged
if this is ignored.)

For the axis $(\hat{u}, \beta)$ form,

\begin{eqnarray}
\label{eq:pureboost}
  \left\{
  \begin{array}{lcl}
  t & \longleftarrow & \gamma t + \beta \gamma \vec{v} \cdot \hat{u} \\
  \vec{v} & \longleftarrow & \vec{v} + \left[
	\frac{\gamma-1}{\beta^2} \beta \vec{v} \cdot \hat{u}  +
	\beta \gamma t \right] \hat{u}
  \end{array}
  \right. \\
  \gamma \equiv \frac{1}{\sqrt{1-\beta^2}} \nonumber
\end{eqnarray}

For the boost vector  $(\vec{\beta})$ form,

\begin{eqnarray}
\label{eq:wboostvec}
  \left\{
  \begin{array}{lcl}
  t & \longleftarrow & \gamma t + \gamma \vec{v} \cdot \vec{\beta} \\
  \vec{v} & \longleftarrow & \vec{v} + \left[
	\frac{\gamma-1}{|\vec{\beta}|^2} \vec{v} \cdot \vec{\beta}  +
	\gamma t \right] \vec{\beta}
  \end{array}
  \right. \\
  \gamma \equiv \frac{1}{\sqrt{1-|\vec{\beta}|^2}} \nonumber
\end{eqnarray}

\subsubsection{Applying \protect\Ro s and \protect\LT s to \protect\SV s}

In CLHEP, the \LV\ class is aware of the existence of the \Ro\ and 
\LT\ classes.  
This is reflected in routines to apply these the \LV :

\begin{equation}
\label{eq:wopstareq}
\left.
\begin{array} {r}
p \mbox{ *= } R \\
p \mbox{.transform} (R) 
\end{array}
\right\}
\Longleftrightarrow
p \leftarrow R p
\end{equation}
\noindent
Notice that these are identical.
In contrast to the usual {\tt operator *=} semantics, 
{\tt p *= R } {\it left} multiplies the matrix representing {\tt p} 
by the matrix representing {\tt R}.

\subsection{Near-equality of \protect\LV s}

We keep in mind that the prime utility of {\tt isNear()} and related methods
is to see whether two vectors, which have been created along two computational
paths or from
two sets of fuzzy quantities, ought mathematically to be taken as equal.
{\em Relative} tolerance is needed,
and this is more involved than just
checking for approximate equality in the time and space sectors respectively.
For example, though no non-zero vector can be near the zero vector,
$(\vec{\epsilon},t=1)$ with $\vec{\epsilon}$ a very small vector
should be considered close to $(\vec{0},t=1)$.

The temptation is to use, as the normaliztion to determine relative nearness,
the length $|\vec{v}|^2 + t^2$.  Let us call this the Euclidean norm, since it
is the norm in complex 4-space $(\vec{v}, i t)$.
This is not Lorentz invariant, but for
many purposes is a good criteria for calling two 4-vectors close.
We use the Euclidean norm to define {\tt isNear()} for {\tt LorentzVectors};
it has the virtue of simplicity and can be applied to any 4-vectors.
Let the method {\tt isNear()} be represented by the symbol $\approx$:

\begin{equation}
\label{eq:wisNear}
  w_1 \approx w_2 \Longleftrightarrow
  \left|
    \vec{v}_1 - \vec{v}_2
  \right| ^2
  + (t_1 - t_2)^2 \leq
  \epsilon^2
  \left[
    \left|
      \vec{v}_1 \cdot \vec{v}_2
    \right|
    +
    \left(
      \frac{t_1 + t_2}{2}
    \right)^2
  \right]
\end{equation}

This definition not Lorentz invariant, but it
is (to order $\epsilon \times \gamma$) independent of frame
within the space of {\em small} Lorentz transformations.
It turns out to be impossible to find a definition which is
Lorentz invariant for all possible 4-vectors, under arbitrarily large
boosts, and still behaves like a measure of near-ness.

A second useful definition, which is Lorentz invariant, but is
sensibly applicable only to timelike 4-vectors,
is to look at the Euclidean norm of the difference of two vectors
{\em in their Center-of-Mass frame}.
This is intuitively appealing to HEP practitioners;
we make this method available as well, calling it {\tt isNearCM()}.

Let the method {\tt isNear()} be represented by the symbol $\approx$,
and the method {\tt isNearCM()} be represented by the symbol
$\stackrel{\mbox{\tiny CM}}{\approx}$.
Let ${\bf w}_{1}$, ${\bf w}_{2}$ be LorentzVectors.
Also, let
$\vec{v}_i, t_i$ be the space vector and time components of ${\bf w}_{i}$.
Then using the boost vector to the joint center of mass frame
\begin{equation}
  \vec{b} = - \frac { \left| \vec{v}_1 + \vec{v}_2 \right| } { t_1 + t_2 }
\end{equation}
\noindent
and assuming that $|\vec{b}| < 1$ so we can take
\begin{eqnarray}
  \beta = |\vec{b}| \\
  \gamma = \frac{1} {\sqrt {1-\beta^2 } }
\end{eqnarray}
\noindent
we define the condition
\begin{eqnarray}
\label{eq:wisNearCM}
  w_1 \stackrel{\mbox{\tiny CM}}{\approx} w_2 \Longleftrightarrow
    \left( w_1\mbox{.boost}(\vec{b}) \right) \approx
    \left( w_2\mbox{.boost}(\vec{b}) \right)
\end{eqnarray}

As mentioned earlier, this criterion makes sense only for timelike 4-vectors.
If applied to 4-vectors whose sum is not timelike, the {\tt isNearCM()}
method will return a test for exact equality.

\begin{eqnarray}
\label{eq:wisNearCM:2}
  \mbox{if  } | \vec{v}_1 + \vec{v}_1 | \geq | t_1 + t_2 | \mbox{ then  }
w_1 \stackrel{\mbox{\tiny CM}}{\approx} w|2 \Longleftrightarrow w_1 = v_2
\end{eqnarray}

\subsubsection{DeltaR for \protect\LV s}
Another method to compare two \LV s is {\tt w1.deltaR(w2)}, which acts only
on the 3-vector components of the \LV s and applies {\tt deltaR} as defined
by equation (\ref{eq:deltaR}).

\subsubsection{Ordering Comparisons for \protect\LV s}

The comparison operators \verb$ ( >, >=, <, <= )$ for \LV\ act by comparing
first the time component, then the \SV\ part. The latter comparison is done
using definition (\ref{eq:compSV}).
\begin{equation}
\label{eq:wcomp}
  w_1 > w_2 \mbox{ if }
	t_1 > t_2 \mbox { or } \left[
	t_1 = t_2 \mbox { and }
	\vec{v}_1 > \vec{v}_2 \right]
\end{equation}

\subsection{Other Boolean Methods for \protect\LV s}

The {\tt w1.isParallel(w2)} method works with a relative tolerance.
If the difference of the normalized 4-vectors is small,
then those 4-vectors are considered nearly parallel.
For this purpose, we use the Euclidean norm to define the normalization and
size of difference.

Let
\begin{eqnarray}
  \overline{w}_1 \equiv \frac{w_1}{|\vec{v}_1|^2 + t_1^2} \nonumber \\
  \overline{w}_2 \equiv \frac{w_1}{|\vec{v}_2|^2 + t_2^2} \nonumber
\end{eqnarray}
\noindent
and
\begin{eqnarray}
  \overline{w}_1 - \overline{w_2} \equiv
  ( \overline{v}_{12} , \overline{t}_{12} ) \nonumber
\end{eqnarray}
\noindent
then
\begin{equation}
\label{eq:wisPar}
  w_1 \parallel w_2 \mbox{ iff }
  \left| \overline{v}_{12} \right| ^2 + \overline{t}_{12}^2 \leq \epsilon^2
\end{equation}

As in the case of \SV s, only the zero 4-vector is considered parallel to
the zero 4-vector.
\begin{equation}
\label{eq:wisPar:2}
  w \parallel (0, 0, 0, 0) \mbox{ iff } w = (0, 0, 0, 0)
\end{equation}

The {\tt w1.howParallel(w2)} method, applied to two non-zero \LV s,
returns the Euclidean norm of the differnce.  This can range from zero
(if {\tt w2} is a positive multiple of {\tt w1}) to
2 (if {\tt w2} is a negative multiple of {\tt w1}).  If both \LV s are
zero, {\tt w1.howParallel(w2)} returns zero; if one is zero, it returns 1.

\vspace{.25 in}

The boolean tests {\tt isSpacelike()}, {\tt isTimelike()},
and {\tt isLightlike()},
work with the {\tt restMass2()} function, which returns $t^2 - |\vec{v}|^2$.

\begin{eqnarray}
\label{eq:wisSl}
  w\mbox{.isSpacelike}() \Longleftrightarrow t^2 - |\vec{v}|^2 < 0 \\
\label{eq:wisTl}
  w\mbox{.isTimelike}()  \Longleftrightarrow t^2 - |\vec{v}|^2 > 0
\end{eqnarray}

The test for {\tt isLightlike()}
uses a tolerance relative to the time component of the vector.
It determines if, starting from an exactly lightlike vector, you can perturb
$t$ and $v$ by a small relative amount to reach the actual
vector.
\begin{equation}
\label{eq:wisLl}
  w\mbox{.isLightlike}() \Longleftrightarrow
  \left| t^2 - |\vec{v}|^2 \right| <= 2 \epsilon t^2
\end{equation}
\noindent
The $2 \epsilon t^2$ limit is chosen such that $(0, 0, (1\pm\epsilon)t, t)$
is just on the boundary of being considered lightlike.

Since the {\tt isLightlike()} method is tolerant of small perturbations,
these three methods are not mutually exclusive: A 4-vector can test true for
{\tt isLightlike()}
and either {\tt isSpacelike()} or {\tt isTimelike()} as well.

By these definitions, the zero 4-vector is considered lightlike.

\subsection{Nearness measures for \protect\LV s}

Since both {\tt isNear()} and {\tt isNearCM()} for \LV s use relative tolerance,
the corresponding nearness measures are truncated at a maximum of 1:

\begin{eqnarray}
\label{eq:whowNear}
  w_1 \mbox{.howNear} (w_2) = \max \left( \sqrt { \frac
    {\left| \vec{v}_1 - \vec{v}_2 \right| ^2 + (t_1 - t_2)^2 }
    { \left| \vec{v}_1 \cdot \vec{v}_2 \right|
      + \left( \frac{t_1 + t_2}{2} \right)^2 }
  } \;, \; 1 \right)
	\\
\label{eq:whowNearCM}
  w_1 \mbox{.howNearCM} (w_2) =
    \left( w_1\mbox{.boost}(\vec{b}) \right)\mbox{.howNear}
    \left( w_1\mbox{.boost}(\vec{b}) \right)
\end{eqnarray}
\noindent
with, as before, the boost vector $\vec{b}$ given by
\[
  \vec{b} = - \frac { \left| \vec{v}_1 + \vec{v}_2 \right| } { t_1 + t_2 }
\]
\noindent
For two unequal \LV s,
{\tt w1.howNearCM(w2)} will return 1
if the boost to the rest frame is tachyonic.

The {\tt w1.isParallel(w2)}
and {\tt w.isLightlike()}
methods also work with a relative tolerance.
The corresponding measures are defined by:
\begin{eqnarray}
\label{eq:whowPar}
  w_1\mbox{.howParallel}(w_2) = \max \left( \sqrt {
    \left| \overline{v}_{12} \right| ^2 +
	\overline{t}_{12}^2 } \; , \; 1 \right)
\end{eqnarray}
\noindent
(where the notation used is that use for equation \ref{eq:wisPar}).

\noindent
If $w = (v,t)$
\begin{eqnarray}
\label{eq:whowLl}
  w\mbox{.howLightlike}() = \max \left(
    \frac { \left| t^2 - |\vec{v}|^2 \right| } { 2 t^2 }
     \; , \; 1 \right)
\end{eqnarray}

\noindent
As before, if this measure is very nearly zero, the 4-vectors are nearly
parallel or the 4-vector is nearly lightlike.

When one of the 4-vectors (but not the other) is zero,
\begin{eqnarray}
\label{eq:whowNear:2}
  w \mbox{.howNear}(\mbox{{\it 0}}) =
  \mbox{{\it 0}} \mbox{.howNear} (w) = 1
	\\
\label{eq:whowNearCM:2}
  w \mbox{.howNearCM}(\mbox{{\it 0}}) =
  \mbox{{\it 0}} \mbox{.howNearCM} (w) = 1
	\\
\label{eq:whowPar:2}
  w \mbox{.howParallel}(\mbox{{\it 0}}) =
  \mbox{{\it 0}} \mbox{.howParallel} (w) = 1
	\\
\label{eq:whowLl:2}
  \mbox{{\it 0}} \mbox{.howLightlike()} = 0
\end{eqnarray}

When both 4-vectors are zero, the nearness measures will all return zero.

\section {Pseudorapidity, Rapidity and CoLinearRapidity}
\label{rapidity}

\noindent
Pseudorapidity (conventionally labelled $\eta$) and rapidity are properties
which apply to both \SV s and \LV s.
Pseudorapidity and rapidity are defined relative to the $z$ direction.

The pseudorapidity {\tt eta} of either a \LV\ or a \SV\ is defined in terms of
the angle the 3-vector part forms with the Z axis:
This can be found knowing nothing of the mass of a particle, and
in the limit of large momentum is approximately the same as the true rapidity.
Unlike the case for rapidity(), eta() makes mathematical sense for any
vector---it a simple function of the tangent of the angle between the vector and
the Z axis.
The pseudorapidity of a zero vector will be assigned the value zero.

Let $\vec{v_1}$ be a \SV, and $w_1$ be a \LV\ with decomposition
$(t, \vec{v})$.
And let the angle formed between the Z axis and
$\vec{v_1}$ or $\vec{v}$ be $\theta$.  Then:

\begin{eqnarray}
\label{eq:eta:3}
  v_1 \mbox{.eta()} = - \ln \tan \frac{\theta}{2} \\
\label{eq:weta:3}
  w_1 \mbox{.eta()} = - \ln \tan \frac{\theta}{2}
\end{eqnarray}


\noindent
The true rapidity of a LorentzVector is defined (see the Kinematics section of
the Review of Particle Properties, page 177 in the 1997 version) such that
the rapidity transforms under a boost {\em along the Z axis}
by adding the rapidity of the boost:
This treats the LorentzVector as a timelike 4-momentum
(using the $t$ and $z$ components as $E$ and $p_z$).

In analogy with the familiar definition for \LV, the rapidity of a \SV\ is
defined with respect to the $z$ direction.
Mathematically, this is the same as the rapidity of a 4-vector
$(\vec{v}, 1)$.

Letting $w_1$ be $(x, y, z, t)$ or $(p_x, p_y, p_z, E)$,

\begin{eqnarray}
\label{eq:wrapid:3}
  w_1 \mbox{.rapidity() }
	= \frac{1}{2} \ln \left( \frac{E + p_z}{E - p_z}    \right)
	= \tanh^{-1} \frac {z}{t} \\
  v_1 \mbox{.rapidity() }
	= \tanh^{-1} (\vec{v}_1 \cdot \hat{z})
\end{eqnarray}

\noindent
The shape of a rapidity distribution is a invariant under boosts in the $z$
direction.
Pseudorapidity can always be determined from direction information alone,
and when $ p^2 \gg m^2 $ {\em and the time component is positive}
pseudorapidity matches rapidity to order $m^2$/$p^2$.

\vspace{.2 in}

Although the $z$ direction is special for many HEP uses,
rapidity and pseudorapidity can be defined with respect to an arbitrary
direction $\hat{u}$.  Letting $w_1$ be $(\vec{v}, t)$:

\begin{eqnarray}
\label{eq:weta:4}
  w_1 \mbox{.eta(u)} = - \ln \tan \frac{\hat{p} \cdot {u}}{2} \\
\label{eq:eta:4}
  v_1 \mbox{.eta(u)} = - \ln \tan \frac{\hat{v}_1 \cdot \hat{u}} {2} \\
\label{eq:wrapid:4}
  w_1 \mbox{.rapidity(u) }
	= \frac{1}{2} \ln \left( \frac{E + \vec{p} \cdot \hat{u}}
				      {E - \vec{p} \cdot \hat{u}} \right)
	= \tanh^{-1} \frac {\vec{v} \cdot \hat{u}} {t} \\
  v_1 \mbox{.rapidity(u) } = \tanh^{-1} (\vec{v}_{1} \cdot \hat{u})
\end{eqnarray}

\noindent
Relativity texts discuss rapidity along the direction of the vector.
This concept can apply to \SV s or \LV s.
This function adds when you compbine two boosts in the same direction.

Such a method may not be needed for typical HEP calculations but
is provided for completeness.
To distinguish this from the rapidity with respect to a specific
direction---or a default rapidity, which is with respect to $\hat{z}$---the
package names the rapidity along the direction of the vector
{\tt coLinearRapidity()}.

\begin{eqnarray}
  v_1 \mbox{.coLinearRapidity() } = \tanh^{-1} \beta
	=  \tanh^{-1} \left|\vec{v_1}\right| \\
\label{eq:wcoLinRap:2}
  w_1 \mbox{.coLinearRapidity() }
	= \frac{1}{2} \ln \left( \frac{E + |p|}{E - |p|}    \right)
	= \tanh^{-1} \frac {|v|}{t}
\end{eqnarray}

\noindent
The co-linear rapidity of a 3-vector is inherently non-negative; for a
4-vector it will have the same sign as the time component of the 4-vector.

\section{\protect\Ro\ Class}

\Ro s may be expressed in terms of an axis $\hat{u}$
and angle $\delta$ of counter-clockwise
rotation, or as a set of three Euler Angles $(\phi, \theta, \psi)$.
Definitions and conventions for these classes
match those described in \S \ref{rotations}
for directly rotating a \SV:

\[  \mbox{HepRotation}(\hat{u},\delta) \Longrightarrow \]
\begin{equation}
\label{eq:axisrotR}
\left(
\begin{array}{ccc}
\cos \delta + (1 - \cos \delta ) u_x^2 &
(1 - \cos \delta ) u_x u_y - \sin \delta u_z &
(1 - \cos \delta ) u_x u_z + \sin \delta u_y \\
(1 - \cos \delta ) u_y u_x + \sin \delta u_z &
\cos \delta + (1 - \cos \delta ) u_y^2 &
(1 - \cos \delta ) u_y u_z - \sin \delta u_x \\
(1 - \cos \delta ) u_z u_x - \sin \delta u_y &
(1 - \cos \delta ) u_z u_y + \sin \delta u_x &
\cos \delta + (1 - \cos \delta ) u_z^2
\end{array}
\right)
\end{equation}

\[  \mbox{HepRotation}(\phi, \theta, \psi) \Longrightarrow  \]
\begin{equation}
\label{eq:eulerrotR}
\left(
\begin{array}{ccc}
\cos \psi \cos \phi - \sin \psi \cos \theta \sin \phi &
\cos \psi \sin \phi + \sin \psi \cos \theta \cos \phi &
\sin \psi \sin \theta \\
- \sin \psi \cos \phi - \cos \psi \cos \theta \sin \phi &
- \sin \psi \sin \phi + \cos \psi \cos \theta \cos \phi &
\cos \psi \sin \theta \\
\sin \theta \sin \phi &
- \sin \theta \cos \phi &
\cos \theta
\end{array}
\right)
\end{equation}
\noindent
The Euler angles definition matches that found in found in
{\em Classical Mechanics} (Goldstein), page 109.
This treats the Euler angles as a sequence of counter-clockwise {\bf passive}
rotations;
that is, the vector remains fixed while the coordinate axes are rotated---new
vector components are computed in new coordinate frame.

HEP computations ordinarily use the active rotation viewpoint.
Therefore, rotations about an axis imply {\bf active} counter-clockwise
rotation in this package. 

Consequently, a rotation by angle $\delta$ around the X axis is
equivalent to a rotation with Euler angles
$(\phi=\psi=0, \mbox{ } \theta = - \delta)$
and a rotation about the Z axis is
equivalent to a rotation with Euler angles
$(\theta = 0, \mbox{ } \phi=\psi= - \delta/2)$.

\subsection{Applying Rotations to Vectors and 4-Vectors}

A \Ro may be applied to a \SV using either of two notations:  

\begin{equation}
\label{eq:Rv}
\mbox{R * v} \equiv \mbox{R(v)} \equiv {\boldmath R} \vec{v}
\end{equation}

\noindent
where ${\boldmath R}$ is the matrix representing R, as in equation
\ref{eq:eulerrotR} or \ref{eq:axisrotR}.  The same syntaxes may be
used to apply a \Ro to a \LV ---the rotation matrix acts on the space
components of the 4-vector.

Note that {\tt R *= v} is meaningless and not supported.  
Also note the warning given earlier:
$ \vec{v} \mbox{*=} R \Longleftrightarrow \vec{v} = R \mbox{*} \vec{v} $

\subsection{Axial Rotations}

The special case rotations along the X, Y, and Z axes will often be specified
by just the rotation angle $\delta$.  Thus a 
{\tt HepRotationX}, {\tt HepRotationY}, or {\tt HepRotationZ}
with angle $\delta$ would be represented by the matrix

\begin{eqnarray}
  \label{eq:rotx}
  \mbox{HepRotationX}(\delta) =
\left(
\begin{array}{ccc}
 1 & 0 & 0 \\
 0 & \cos \delta & - \sin \delta \\
 0 & \sin \delta & \cos \delta 
\end{array}
\right) \\
  \label{eq:roty}
  \mbox{HepRotationY}(\delta) =
\left(
\begin{array}{ccc}
 \cos \delta & 0 & \sin \delta \\
 0 & 1 & 0 \\
 - \sin \delta & 0 & \cos \delta 
\end{array}
\right) \\
  \label{eq:rotz}
  \mbox{HepRotationZ}(\delta) =
\left(
\begin{array}{ccc}
 \cos \delta & - \sin \delta & 0 \\
 \sin \delta & \cos \delta & 0 \\
 0 & 0 & 1
\end{array}
\right) \\
\end{eqnarray}

A \Ro\ is an object in its own right; two \Ro s may be multiplied,
tested for near equality, and so forth.
Multiplication is done by multiplying the matrix representations of two
\Ro s (though for matching axis rotations, simplifications are
done to effciently compute this product).

The matrix representing a \Ro\ is orthonormal:  Each row, considered
as a vector, has length 1, and the dot product of any two distinct rows
is zero.  This leads to a trivial inversion method---simply transpose the
matrix.

When dealing with structures holding an axis and angle, or Euler angles,
we do not provide direct analogues of all rotation methods.  For example,
we do not provide for multiplication of two \Ax objects to form a third
\Ax.  We do provide comparison and nearness methods for these classes,
and this document specifies whether the criteria match the corresponding
\Rotation\ criteria.

\subsection{Expressing a \protect\Ro\ as \protect\Ax\ or \protect\Es\ }

It is worth noting that equations (\ref{eq:axisrot}) and (\ref{eq:eulerrot})
are not single-valued when extracting $ ( \hat{u}, \delta) $ or
$ ( \phi, \theta, \psi ) $ from a \Rotation\ matrix.  We adhere to the
following conventions to resolve that ambiguity whenever forming an
\Ax\ from a \Rotation\ $R$:
\begin{eqnarray}
  R = {\bf I} \Longrightarrow \delta = 0, \; \hat{u} = \hat{z}
	\\
	\label{eq:deltaconv}
  R \longrightarrow ( \hat{u}, \delta ) \Longrightarrow 0 \leq \delta \leq \pi
\end{eqnarray}

And we adhere to the
following conventions to resolve that ambiguity whenever forming an
\Es\ from a \Rotation\ $R$:
\begin{eqnarray}
 \label{eq:thetaconv}
  R \longrightarrow ( \phi, \theta, \psi )
	\Longrightarrow 0 \leq \theta \leq \pi
	\\
 \label{eq:tphiconv}
  R \longrightarrow ( \phi, \theta, \psi )
	\Longrightarrow -\pi < \phi \leq \pi
	\\
 \label{eq:psiconv}
  R \longrightarrow ( \phi, \theta, \psi )
	\Longrightarrow -\pi < \psi \leq \pi
	\\
 \label{eq:phipsiconv}
  R \longrightarrow ( \phi, \; \theta = 0, \; \psi )
	\Longrightarrow -\pi/2 < \phi = \psi \leq \pi/2
	\\
  R \longrightarrow ( \phi, \; \theta = \pi, \; \psi )
	\Longrightarrow -\pi/2 < \phi = -\psi \leq \pi/2
\end{eqnarray}
\noindent
Thus when supplying values for Euler angles,
we return $(0, 0, 0)$ whenever the rotation is
equivalent to the identity, and return $(0, \pi, 0)$ in preference to
the equivalent $(\pi, \pi, \pi)$.

In particular, special case rotations such as
{\tt HepRotationX} with $\delta$ supplied as zero or $\pi$
obey these conventions:  even though for $\delta = \pi - |\epsilon|$
a {\tt RotationX} would have Euler angles $( \pi, \delta, \pi, )$,
when $\delta = \pi$ exactly, the Euler angles are $(0, \delta=\pi, 0)$.

These conventions for how methods return values for Euler angles
do not affect the user's right to supply explicit values for
or $ ( \phi, \theta, \psi ) $ which may not obey the conventions,
when defining an \Es\ structure or a \Rotation--it is just that when
such a \Rotation\ is read back as Euler angles, the values will not be
the ones originally supplied.
Similarly, the conventions for reading axis and angle do not affect the
user's ability to supply arbitrary $ ( \hat{u}, \delta) $ values.

Obeying the above rules, Euler angles returned for
rotations about coordinate axes behave as follows:

\begin{equation}
\mbox{HepRotationX}(\delta) \longrightarrow
\left\{
\begin{array}{ccc}
( 0, -\delta, 0 ) & \mbox{ if } & \delta \leq 0 \\
( \pi, \delta, \pi ) & \mbox{ if } & 0 < \delta < \pi \\
( 0, \pi, 0 ) & \mbox{ if } & \delta = \pi
\end{array}
\right.
	\label{eq:rotXconv}
\end{equation}

\begin{equation}
\mbox{HepRotationY}(\delta) \longrightarrow
\left\{
\begin{array}{ccc}
( +\pi/2, -\delta, -\pi/2 ) & \mbox{ if } & \delta <  0 \\
( 0, 0, 0) & \mbox{ if } & \delta = 0 \\
( -\pi/2, \delta, +\pi/2 ) & \mbox{ if } & 0 <  \delta < \pi \\
( \pi/2, \delta, -\pi/2 ) & \mbox{ if } & \delta = \pi
\end{array}
\right.
	\label{eq:rotYconv}
\end{equation}

\begin{equation}
\mbox{HepRotationZ}(\delta) \longrightarrow ( -\delta/2, 0, -\delta/2 )
	\label{eq:rotZconv}
\end{equation}
\noindent always assuming that $\delta$ represents an angle of active rotation
between $-\pi$ and $\pi$.

\subsection{Nearness Measure for \protect\Ro s, \protect\Ax s, and \protect\Es\ }

The definition used for {\tt isNear()} and {\tt howNear()} on \Rotation s
has the following properties:
\begin{enumerate}
\item {\tt isNear()} and {\tt howNear()} use the same measure:  Two rotations
are considered near if their {\tt howNear()} measure is less that $\epsilon$.
\item Transitivity:  $r_1 \approx r_2$ and {\tt r1.howNear(r2)}
are exactly equivalent to $r_2 \approx r_1$ and {\tt r2.howNear(r1)}.
\item Rotational invariance to order $\epsilon$:
If $x = ${\tt r1.howNear(r2)} is small, then for any third rotation {\tt r3}
 {\tt (r3*r1).howNear(r3*r2)} $ x + O(x^2)$.
\item For the special case of rotations that happen to be around the same axis,
the measure agrees with a natural definition for measure of rotation about an
axis (\S\ref{rotsame}).
\end{enumerate}

Although it is possible to formulate a measure definition with exact rotational
in\-var\-i\-ance---based on $
\sup_{\hat{u}} \left\{
\left| R_1(\hat{u}) - R_2(\hat{u}) \right|
\right\}
$---this definition would require finding the 2-norm (or the largest eigenvalue)
of the matrix $r_1 r_2^{-1}$, which is computationally difficult.
The measure we use is the same for small answers, and has the above desirable
properties.
\begin{eqnarray}
\label{eq:nearrot}
  r_1 \mbox{.howNear}(r_2) = \sqrt{ 3 - \mbox{Tr}(r_1 r_2^{-1}) }
	= \sqrt {3 - \sum_{ij} r_{1_{ij}} r_{2_{ij}} }
	\\
\label{eq:dist2rot}
  r_1 \mbox{.distance2}(r_2) = 3 - \mbox{Tr}(r_1 r_2^{-1}) 
	= 3 - \sum_{ij} r_{1_{ij}} r_{2_{ij}} 
	\\
  r_1 \approx r_2 \Longleftrightarrow 3 - \mbox{Tr}(r_1 r_2^{-1})
		\leq \epsilon^2
\end{eqnarray}

And a norm is provided:
\begin{eqnarray}
\label{eq:norm2rot}
  r_1 \mbox{.norm2}(~) = 3 - \mbox{Tr}(r_1) 
\end{eqnarray}


\Ax s have the property that two apparently unequal forms may be equivalent,
for example if the axes are in opposite directions and one angle is the
negative of the other.  
Similarly, two different-looking \Es\ can represent the same
rotation.  To avoid a whole spectrum of special cases, we adapt the rule that,
letting $\Upsilon$ be an \Ax and $\Xi$ be an \Es\ structure, and
$R(\Upsilon), R(\Xi)$ be the corresponding \Ro s,
\begin{eqnarray}
  \Upsilon_1 \mbox{.howNear} (\Upsilon_2) \equiv
	R \left( \Upsilon_1 \right) \mbox{.howNear}
	\left( R \left( \Upsilon_2 \right) \right)
	\\
  \Xi_1 \mbox{.howNear} (\Xi_2) \equiv
	R \left( \Xi_1 \right) \mbox{.howNear}
	\left( R \left( \Xi_2 \right) \right)
\end{eqnarray}

Since for double precision computations these nearness measures cannot 
count on precision to better than $10^{-8}$, 
the default tolerance for Rotations 
(which may be modified by the class static method {\tt setTolerance()}) 
is set to 100 times that.
\begin{equation}
  \epsilon_{\mbox{default}} =  10^{-6}
\label{eq:epsildefR}
\end{equation}

\subsubsection{Nearness for \protect\Ro s About the Same Axis}
\label{rotsame}

The above definition of {\tt howNear()} for two general \Rotation s reduces,
when both \Rotation s are around the same axis by angles $\delta_1$ and
$\delta_2$, to

\begin{equation}
 r_1 \mbox{.howNear} (r_2) = \sqrt{ 2 - 2 \cos (\delta_1 - \delta_2) }
 = | \delta_1 - \delta_2 | + O \left( (\delta_1 - \delta_2)^3 \right)
\end{equation}
\noindent
(Note that when the two rotations are special-case coordinate axis rotations,
computing the cosine of that angle difference is trivial, given
that the structures already hold the sine and cosine of $\delta_i$.)

Although equivalent for most small angular differences to the simpler concept
of $ | \delta_1 - \delta_2 | $, the definition above also properly handles the
case where one $\delta$ is near $\pi$ and the other near $-\pi$.

\subsection{Comparison for \protect\Ro s, \protect\Ax s, and \protect\Es\ }

It is useful to have definitions of the various comparison operators
so that \Ro s, \Ax s, and \Es\ can be placed into {\tt std::} containers.

Of the three classes, \Ax\ has a natural meaning for ordering comparisons,
taking advantage of the ordering relation already available for the \UV\
axes:
\begin{equation}
\label{eq:ordrot}
  ( \hat{u}_1 , \delta_1 ) > ( \hat{u}_2 , \delta_2 ) \mbox{ if }
	\hat{u}_1 > \hat{u}_2  \mbox { or } \left[
	\hat{u}_1 = \hat{u}_2  \mbox { and }
	\delta_1 > \delta_2  \right]
\end{equation}

For \Rotation, we could use the ordering induced by its \Ax\ expression;
extracting the \Ax\ corresponding to a \Ro\ is a fairly simple task.  
But that is unnecessarily complex--instead, we use dictionary ordering,
starting with $zz, zy, zx, yz, \ldots, xx$.  This agrees with the definition
used in the orignal CLHEP Vector package.

For \Es, rather than laboriously going over to \Ro s and then using the
induced dictionary ordering comparison, we adapt simple dictionary ordering:
\begin{eqnarray}
  ( \phi_1 , \theta_1, \psi_1 ) > ( \phi_2 , \theta_2, \psi_2 ) \mbox{ if }
	\nonumber \\
	\phi_1 > \phi_2  \mbox { or }
	\nonumber \\
	\left[
	\phi_1 = \phi_2  \mbox { and } 	\theta_1 > \theta_2  \right]
	\mbox { or }
	\nonumber \\
	\left[
	\phi_1 = \phi_2  \mbox { and } 	\theta_1 = \theta_2
	\mbox { and } \psi_1 > \psi_2
	\right]
\end{eqnarray}

Because we use dictionary ordering comparisons, one \Ro\ may be considered
greater than another, but if you take may Euler angles (or for that matter
their \Ax\ structures), the comparison may have the opposite sense.

\subsection{The Rotation Group}

Inversion of a \Ro\ is supported.  Since the matrix is orthogonal,
the inverse matches the transpose:
\[
  R\mbox{.inverse()} \equiv R^{-1} = R^T
\]

Multiplication is available in three syntaxes:
\begin{eqnarray}
\label{eq:opmulrot}
	\mbox{ R = R1 * R2} \Longrightarrow {\boldmath R = R_1 R_2}
\label{eq:opstrot}
	\\
	\mbox{ R *= R1 } \Longrightarrow {\boldmath R = R R_1 }
	\\
\label{eq:transrot}
	\mbox{ R.transform(R1) } \Longrightarrow {\boldmath R = R_1 R }
\end{eqnarray}

To complete the group concept, the identity \Ro\ can easily be obtained; the
default constructor for \Ro\ gives the identity.

Two sorts of specialized transformations are available.  The first transforms
by a rotation around an axis:
\begin{eqnarray}
\label{eq:xyzrot}
  R\mbox{.rotateX}(\delta) \Longrightarrow R = \mbox{RotationX}(\delta) R \\
\nonumber
  R\mbox{.rotateY}(\delta) \Longrightarrow R = \mbox{RotationY}(\delta) R \\
\nonumber
  R\mbox{.rotateZ}(\delta) \Longrightarrow R = \mbox{RotationZ}(\delta) R 
\end{eqnarray}
\noindent
The other specialized transformation rotates such that the original X axis
becomes a specified new X axis, and similarly for the Y and Z axes.
In the specified new axes are labeled $\vec{X}^\prime$, $\vec{Y}^\prime$, 
$\vec{Z}^\prime$, this transformation is equivalent to:
\begin{equation}
\label{eq:rotaxes}
\mbox{R.rotateAxes}(X^\prime, Y^\prime, Z^\prime) \Longrightarrow
{\boldmath R} = 
\left(
\begin{array}{ccc}
X^\prime_x & Y^\prime_x & Z^\prime_x \\
X^\prime_y & Y^\prime_y & Z^\prime_y \\
X^\prime_z & Y^\prime_z & Z^\prime_z 
\end{array}
\right)
{\boldmath R} 
\end{equation}
\noindent
The supplied 
$\vec{X}^\prime$, $\vec{Y}^\prime$ and $\vec{Z}^\prime$ must be orthonormal;
no checking is done, and if the supplied new axes are not orthonormal, the
result will be an ill-formed (non-orthogonal) rotation matrix.

\subsection{Rectifying Rotations}

The operations on \Ro s are such that mathematically, the orthonormality of 
the representation is always preserved.  And methods take advantage of this 
property. 
However, a long series of operations could, due to round-off, produce a 
\Ro\ object with a representation that slightly deviates from the  
mathematical
ideal.  This deviation can be repaired by extracting the axis and delta
for the \Ro, and freshly setting the axis and delta to those values.

\begin{equation}
\label{eq:rectRot}
\mbox{R.rectify()} \rightarrow \mbox{R.set (R.axis(), R.delta())}
\end{equation}

A technical point:  If the rotation has strayed significantly from a true
orthonormal matrix, then extracting the axis is not necessarily an accurate
process.  To minimze such effects, before performing the formal algorithm
to extract the axis, the rectify() method averages the purported rotation 
with the transpose of its inverse.  (A true rotaion is identical to the 
transpose of its inverse).  This in principle eliminates errors to lowest 
order.


\section{\protect\LT\ Class}

A \LT\ may be
expressed in terms of a \Rotation\ in the space sector, followed by
a pure \LB\ along some direction.
Alternatively, it may be expressed as a pure boost followed by a rotation.

In any event, just as for rotations,
we use the convention of active transformations changing 4-vectors
(rather than transformations of a reference frame).  So a boost by
$\beta$ along the in the X direction, for example, would be represented by
the matrix

\begin{equation}
\label{eq:boostx}
  \mbox{LorentzBoost}(\beta) =
\left(
\begin{array}{cccc}
 \gamma & 0 & 0 & \beta \gamma \\
 0 & 1 & 0 & 0 \\
 0 & 0 & 1 & 0 \\
 \beta \gamma & 0 & 0 & \gamma
\end{array}
\right)
\end{equation}

A \LT\ is an object in its own right; two \LT s may be multiplied,
tested for near equality, and so forth.
Multiplication is done by multiplying the matrix representations of two
\LT s.

The matrix representing a \LT\ is orthosymplectic:  The last (T) row,
constdered as a 4-vector, has $ t^2 - |\vec{v}|^2 = 1 $, each of rows
X, Y, and Z have $ t^2 - |\vec{v}|^2 = -1$, and the Minkowski space
dot product of any two distinct rows
is zero.  This leads to a trivial inversion method---simply transpose the
matrix and negate any elment with just one of its two indices refering to
a space direction.

\subsection{Pure Lorentz Boosts}

Definitions and
and conventions for a pure boost classes match those described in equation
(\ref{eq:pureboost}).
Here we will write out the matrix in detail, for a boost specified by
$\vec{b}$, a \SV\ with magnitude $0 < \beta < 1$ (here we write
$\vec{b} = \beta \hat{u} $ and
$\gamma \equiv \frac{1}{\sqrt{1-\beta^2}}$):

\begin{eqnarray}
\label{eq:boostform}
  \mbox{LorentzBoost}(\beta \hat{u}) =
  \left(
  \begin{array}{cccc}
  (\gamma - 1) u_x^2 + 1 & (\gamma - 1) u_x u_y &
  (\gamma - 1) u_x u_z & \beta \gamma u_x
	\\
  (\gamma - 1) u_y u_x & (\gamma - 1) u_y^2 + 1 &
  (\gamma - 1) u_y u_z & \beta \gamma u_y
	\\
  (\gamma - 1) u_z u_x & (\gamma - 1) u_z u_y &
  (\gamma - 1) u_z^2 + 1 & \beta \gamma u_z
	\\
  \beta \gamma u_x & \beta \gamma u_y & 
  \beta \gamma u_z & \gamma
  \end{array}
  \right)
\end{eqnarray}

\subsubsection{isNear() and howNear() for LorentzBoost}

Though a pure boosts may be specified by a \SV\ of magnitude less than one,
we do not define a nearness measure as the (relative) measure that induced
by those \SV s.  This is because two \LB s in the same direction
with large but quite different
values of $\gamma$ should be viewed as quite different transformations.
The \SV s representing two such boosts would both be very close to the same
unit vector.  That is, (.9999, 0, 0) and (.999999, 0, 0) are not very similar:
The former would boost a muon to 10 GeV, while the latter would boost it to
200 GeV; yet as \SV s, (.9999, 0, 0) is equal to (.999999, 0, 0) within
a relative tolerance $10^{-4}$.

LorentzBoosts have a natural scale, set by the speed of light, so absolute
rather than relative tolerances are appropriate.
The correct way to measure nearness is to find the difference between the
values of $\gamma b$.  If $\vec{\beta}_1$ and 
$\vec{\beta}_2$ specify two pure boosts
$B_1$ and $B_2$
and $\gamma_i \equiv \frac{1}{\sqrt{1 - |\vec{\beta}_i|^2}}$ then
\begin{eqnarray}
\label{eq:nearboost}
    B_1 \mbox{.isNear} (B_2) \Longleftrightarrow
	\left| \gamma_1 \vec{\beta}_1 - \gamma_2 \vec{\beta}_2 \right|^2 \leq
	\epsilon^2
	\\
\label{eq:hownearboost}
    B_1 \mbox{.howNear} (B_2) =
	\left| \gamma_1 \vec{\beta}_1 - \gamma_2 \vec{\beta}_2 \right|
	\\
    B_1 \mbox{.distance2} (B_2) =
	\left| \gamma_1 \vec{\beta}_1 - \gamma_2 \vec{\beta}_2 \right|^2
	\\
\label{eq:boostnorm2}
    B\mbox{.norm2}( ) \equiv B\mbox{.distance2} (I) 
					= \gamma^2 \beta^2 = 1 - \gamma^2 
\end{eqnarray}

\subsubsection{Ordering Comparisons of LorentzBoosts}

Any pure boost can be viewed as having a non-negative $\beta$, and s
direction.
For pure boosts in the same direction both with positive $\beta$,
we wish to order LorentzBoosts according $\beta$:
\begin{equation}
\label{ordboost}
  \mbox{LorentzBoost}( \beta_1 > 0, \hat{u} ) >
  \mbox{LorentzBoost}( \beta_2 > 0, \hat{u} ) \Longleftrightarrow
  \beta_1 > \beta_2
\end{equation}

For pure boosts which may be in different directions,
we use a comparison
condition induced by the \SV s specifying the two boosts.
But in order to match the above ordering for identical directions, we must
reverse the sense of the naive induced ordering when both vectors are
negative.  That is, we want to say that the boost (-.2, -.2, -.2) is
``more than'' the boost (-.1, -.1, -.1).

\begin{eqnarray}
  \mbox{LorentzBoost}( \vec{\beta}_1 ) > \mbox{LorentzBoost}( \vec{\beta}_2 )
	\mbox{ if }
\left\{
  \begin{array}{ccc}
  ( \vec{\beta}_1 \geq \vec{0} & \mbox{ and } &
  \vec{\beta}_1 > \vec{\beta}_2 ) \\
	& \mbox{or} \\
  ( \vec{\beta}_2 < \vec{0} & \mbox{ and } &
  \vec{\beta}_1 < \vec{\beta}_2 )
  \end{array}
\right.
\end{eqnarray}


\subsection{Components of HepLorentzRotations}

Beyond the obvious methods returning single components, such as 
{\tt lt.yt()} there is also the method {\tt rep4x4()}, 
which returns a struct of type {\tt HepRep4x4}---this has publicly
visible data members {\tt xx\_, xy\_, $\ldots$, tz\_, tt\_}.  These
methods may also be used for pure {\tt HepBoost} boosts.  For those
classes, there is also a method {\tt rep4x4Symmetric()}, which returns
a ten-element struct {\tt HepRep4x4Symmetric}.

For \LT, there are also indexing methods with syntax
{\tt lt[i][j]} and {\tt lt(i,j)}.  
In this syntax, the indices range from 0 to 3, with the time component last.
That is, 0 refers to an X component, 1 to Y, 2 to Z, and 3 to T.
If R is the four by four representation of a \LT\ L, then:

\begin{eqnarray}
\label{eq:ltsubscript}
\begin{array}{llll}
  L [0] [0] = R_{xx} & L [0] [1] = R_{xy} &
  L [0] [2] = R_{xz} & L [0] [3] = R_{xt} \\
\nonumber
  L [1] [0] = R_{yx} & L [1] [1] = R_{yy} &
  L [1] [2] = R_{yz} & L [1] [3] = R_{yt} \\
\nonumber
  L [2] [0] = R_{zx} & L [2] [1] = R_{zy} &
  L [2] [2] = R_{zz} & L [2] [3] = R_{zt} \\
\nonumber
  L [3] [0] = R_{tx} & L [3] [1] = R_{ty} &
  L [3] [2] = R_{tz} & L [3] [3] = R_{tt} 
\end{array}
\end{eqnarray}

\subsection{Decomposition of Transformations into Boost and Rotation}

A \LT\ $T$ may be decomposed either into the form $ B R $ or the form
$ R B $.  Here we will refer to the 
first form as $T = \acute{B}(T) \grave{R}(T)$
and the second as $T = \acute{R}(T) \grave{B}(T)$.

When decomposing into the product $ B R $, the boost
will have the same last column as the \LT\ $T$.  Using the value of
$\gamma$ read off $T_{tt}$, one can apply equation (\ref{eq:boostform}) to
find the matrix $\acute{B}(T)$ for that boost.  Then
\begin{equation}
\label{eq:decomBR}
  \grave{R}(T) = \left[ \acute{B}(T) \right] ^{-1} T
\end{equation}

When decomposing into the product $ R B $, the boost
will have the same last row as the \LT\ $T$.  Again
one can apply equation (\ref{eq:boostform}) to
find the matrix (this time $\grave{B}(T)$) for that boost.  Then
\begin{equation}
\label{eq:decomRB}
  \acute{R}(T) = T \left[ \grave{B}(T) \right] ^{-1}
\end{equation}

Naively applying the above equations leads to non-neglible round-off errors 
in the components of the Rotation---of order $3 \cdot 10^{-14}$ if the
boost has $\beta = .95$.
Since a Rotation representation which is non-orthogonal on that scale would 
lead to errors in distance measures of more than one part in $10^{-7}$,
the decompose() method rectifies the Rotation before returning.

\subsection{isNear() and howNear() for \protect\LT s}

For \LT s, the analog of the the \Rotation measure (\ref{eq:nearrot}) would be
\[
  T_1 \mbox{.howNear}(T_2) = \sqrt{ 4 - \mbox{Tr}(T_1 T_2^{-1}) }
\]

This, however, would be a horrible definitition of distance since that trace
can equal 4 for very different $T_1$ and $T_2$.  Instead, we use a definition
which matches the definitions (\ref{eq:nearrot}) and (\ref{eq:hownearboost})
for \LT s which happen to be pure boosts or pure rotations:
\begin{eqnarray}
\label{eq:isnearLT}
\mbox{if } T_1 = B_1 R_1 \mbox{ and } T_2 = B_2 R_2 \nonumber \\
\mbox{then } T_1\mbox{.distance2}(T_2) = 
	B_1\mbox{.distance2}(B_2) + R_1\mbox{.distance2}(R_2)
	\\
\nonumber
T_1\mbox{.howNear}(T_2) = \sqrt {T_1\mbox{.distance2}(T_2)}
\end{eqnarray}
\noindent
The {\tt isNear()} relationship uses this same measure, but when the
transformations have boosts that differ by more that $\epsilon$, {\tt isNear()}
will be quite a bit quicker since the boost portion of this formula is trivial
to compute.

And, as usual, {\tt norm2()} is the squared distance from the identity:
\begin{equation}
\label{eq:ltnorm2}
T = B R \Longrightarrow T\mbox{.norm2}() = 
	B.\mbox{.norm2}() + R\mbox{.norm2}()
\end{equation}

\subsection{Ordering Comparisons of \protect\LT s}

The \verb$ ( >, >=, <, <= )$ comparisons of \LT s are defined as those
induced by the decomposition $ T = \acute{B} \grave{R} $,
comparing the pure boost part
(using (\ref{ordboost})) and
then, if those are equal, comparing the rotation part (using (\ref{eq:ordrot})).

\begin{eqnarray}
\label{eq:ltorder}
  T_1\mbox{.compare}(T_2) = 1 \mbox{ if }
	\acute{B}_1 > \acute{B}_2 \mbox { or } \left[
	\acute{B}_1 = \acute{B}_2 \mbox { and }
	\grave{R}_1 > \grave{R}_2 \right] \\
\nonumber
  T_1\mbox{.compare}(T_2) = -1 \mbox{ if }
	\acute{B}_1 < \acute{B}_2 \mbox { or } \left[
	\acute{B}_1 = \acute{B}_2 \mbox { and }
	\grave{R}_1 < \grave{R}_2 \right] \\
\nonumber
  T_1\mbox{.compare}(T_2) = 0 \mbox{ if }
	\acute{B}_1 = \acute{B}_2 \mbox { and } 
	\grave{R}_1 = \grave{R}_2 
		\\
  T_1  > T_2 \mbox{ if } T_1\mbox{.compare}(T_2) = 1 \\
\nonumber
  T_1  < T_2 \mbox{ if } T_1\mbox{.compare}(T_2) = -1 
\end{eqnarray}

Although \verb$==$ and \verb$!=$ comparisons could use this same comparison
algorithm, decomposition is expensive and unnecessary.  Instead,

\begin{eqnarray}
\label{eq:ltexact}
  T == S  \Longleftrightarrow 
  \left\{
  \begin{array}{cccc}  
  T_{xx} = S_{xx} \wedge & T_{xy} = S_{xy} \wedge &
  T_{xz} = S_{xz} \wedge & T_{xt} = S_{xt} \wedge \\
  T_{yx} = S_{yx} \wedge & T_{yy} = S_{yy} \wedge &
  T_{yz} = S_{yz} \wedge & T_{yt} = S_{yt} \wedge \\
  T_{zx} = S_{zx} \wedge & T_{zy} = S_{zy} \wedge &
  T_{zz} = S_{zz} \wedge & T_{zt} = S_{zt} \wedge \\
  T_{tx} = S_{tx} \wedge & T_{ty} = S_{ty} \wedge &
  T_{tz} = S_{tz} \wedge & T_{tt} = S_{tt} 
  \end{array}
  \right.
\end{eqnarray}

\subsection{The Lorentz Group}

Inversion of a \LT\ is supported.  Since the matrix is orthosymplectic,
the inverse matches the transpose, but with the signs of all components
with mixed space and time indices reversed.

Multiplication is available in three syntaxes:

\begin{eqnarray}
	\mbox{ T = T1 * T2} \Longrightarrow {\boldmath T = T_1 T_2}
	\\
	\mbox{ T *= T1 } \Longrightarrow {\boldmath T = T T_1 }
	\\
\label{eq:lttrans}
	\mbox{ T.transform(T1) } \Longrightarrow {\boldmath T = T_1 T }
\end{eqnarray}

To complete the group concept, the identity \LT\ can easily be obtained; the
default constructor for \LT\ gives the identity.

Specialized transformations based on pure rotations and pure boosts 
are available.  

\begin{eqnarray}
\label{eq:ltrot}
  T\mbox{.rotate}(\delta, \vec{v}) \Longrightarrow T = 
		\mbox{Rotation}(\delta, \vec{v}) T \\
\nonumber
  T\mbox{.rotateX}(\delta) \Longrightarrow T = \mbox{RotationX}(\delta) T \\
\nonumber
  T\mbox{.rotateY}(\delta) \Longrightarrow T = \mbox{RotationY}(\delta) T \\
\nonumber
  T\mbox{.rotateZ}(\delta) \Longrightarrow T = \mbox{RotationZ}(\delta) T 
\end{eqnarray}

\begin{eqnarray}
\label{eq:ltboost}
  T\mbox{.boost}(\vec{\beta}) \Longrightarrow T = 
		\mbox{HepBoost}(\vec{\beta}) T \\
\nonumber
  T\mbox{.boost}(\beta_x, \beta_y, \beta_z) \Longrightarrow T = 
		\mbox{HepBoost}(\beta_x, \beta_y, \beta_z) T \\
\nonumber
  T\mbox{.boostX}(\beta) \Longrightarrow T = \mbox{HepBoostX}(\beta) T \\
\nonumber
  T\mbox{.boostY}(\beta) \Longrightarrow T = \mbox{HepBoostY}(\beta) T \\
\nonumber
  T\mbox{.boostZ}(\beta) \Longrightarrow T = \mbox{HepBoostZ}(\beta) T 
\end{eqnarray}


\subsection{Rectifying HepLorentzRotations}

The operations on \LT s are such that mathematically, the ortosymplectic
property of 
the representation is always preserved.  And methods take advantage of this 
property. 
However, a long series of operations could, due to round-off, produce a 
\LT\ object with a representation that slightly deviates from the  mathematical
ideal.  This deviation can be repaired by extracting the boost vector based on
row 4, multiplying by the inverse of that boost to form what should ideally be 
a rotation, rectifying that rotation, and setting the \LT\ ,based on that boost
and rotation.

\begin{eqnarray}
\label{eq:rectLT}
\mbox{T.rectify()} \rightarrow \nonumber \\
  \vec{\beta} = \mbox {T.row4()} \nonumber \\
  R = T \mbox{ Boost}(-\vec{\beta})   \nonumber \\
  \mbox {drop time components of R} \nonumber \\
  \mbox {R.rectify()} 		    \nonumber \\
  T = R \mbox{ Boost}(\beta)
\end{eqnarray}

\newpage
\section{When Exceptions Occur}


Although this section is not about mathematical definitions, it may be useful
to understand what will happen if the user code sends a method  
data which does not make physical or mathematical sense.  For example, 
a user may supply a vector of magnitude greater than one, to a method
which will use that data to form a Boost.  The resulting tachyonic boost
is unlikely to be the result the user had intended.

\subsection{How Problems Are Dealt With}

In general, the package is configurable in one of three ways:
\begin{enumerate}
\item
If {\tt ENABLE\_ZOOM\_EXCEPTIONS} is defined, then the Zoom Exceptions
package is used.  This allows the user code to control the behaviour to 
a considerable extent, including ignoring versus handling specific types
of exceptional conditions and checking a stack of prior potential throws.
Ultimately, an unhandled exception which is deemed or serious severity will
throw a C++ exception, which if un-caught will cause the program to terminate.
\item
If {\tt ENABLE\_ZOOM\_EXCEPTIONS} is defined, but C++ exceptions are not
enabled (some compilers have a switch to do this; some experiments choose
to use this switch in an effort to improve performance) then the behavior
for an unhandled serios exception is to explicitly abort.
\item
If {\tt ENABLE\_ZOOM\_EXCEPTIONS} is defined, then this compilation is designed
for CLHEP, which currently does not use the Zoom Exception package.
In that case, each problem will cause a message to be emitted on {\em cerr}.
In addition, the various problems which were deemed too severe to
ignore will throw actual C++ exceptions.  These are all derived from
a class {\tt CLHEP\_vector\_exception} which is in turn derived from 
the {\tt std::exception} class - see section 14.10 in Stroustrup.  
User code catching a general {\tt CLHEP\_vector\_exception} can call the
virtual method {\em what()} to get a complete text message, or {\em name()}
to just get the exception name.  
\end{enumerate}

\subsection{Possible Exceptions}

The following sorts of problems may be detected (and reported to {\em cerr}
by the Vector package,
and may in some circumstances be non-ignorable.  
If the problem can't be ignored, then the corresponding exception 
(derived from {\tt CLHEP\_vector\_exception} is thrown.

\begin{description} 
\item [ZMxPhysicsVectors]
Parent exception of all ZMexceptions
particular to classes in the package.
\item [ZMxpvInfiniteVector]
Mathematical operation will lead
to infinity or NAN in a component
of a result vector.
\item [ZMxpvZeroVector]
A zero vector was used to specify
a direction based on vector.unit().
\item [ZMxpvTachyonic]
A relativistic kinematic function was
taken, involving a vector representing
a speed at or beyond that of light (=1).
\item [ZMxpvSpacelike]
A spacelike 4-vector was used in a
context where its restMass or gamma
needs to be computed:  The result is
formally imaginary (a zero result is
supplied).
\item [ZMxpvInfinity]
Mathematical operation will lead
to infinity as a Scalar result.
\item [ZMxpvNegativeMass]
Kinematic operation, e.g. invariant
mass, rendered meaningless by an input
with negative time component.
\item [ZMxpvVectorInputFails]
Input to a SpaceVector or Lorentz
Vector failed due to bad format or EOF.
\item [ZMxpvParallelCols]
Purportedly orthogonal col's supplied
to form a Rotation are exactly
parallel instead.
\item [ZMxpvImproperRotation]
 Orthogonal col's supplied form a
 refection (determinant -1) more
 nearly than rather than a rotation.
\item [ZMxpvImproperTransformation]
Orthogonalized rows supplied form a
tachyonic boost, a reflection, or
a combination of those flaws,
more nearly than a proper Lorentz
transformation.
\item [ZMxpvFixedAxis]
Attempt to change a RotationX,
RotationY, or RotationZ in such a way
that the axis might no longer be X,
Y, or Z respectively.
\item [ZMxpvIndexRange]
When using the syntax of v(i) to get
a vector component, i is out of range.
\end{description}


The following sorts of problems may be detected (and reported to {\em cerr}
by the Vector package, as warnings.  
In these cases, the methdos have sensible behaviors avaialble, and will continue
processing after reporting the warning.

\begin{description} 
\item [ZMxpvNotOrthogonal]
Purportedly orthogonal col's supplied
to form a Rotation or LT are not
orthogonal within the tolerance.
\item [ZMxpvNotSymplectic]
A row supplied to form a Lorentz
transformation has a value of restmass
incorrect by more than the tolerance:
It should be -1 for rows 1-3,
+1 for row 4.
\item [ZMxpvAmbiguousAngle]
Method involves taking an angle against
a reference vector of zero length, or
phi in polar coordinates of a vector
along the Z axis.
\item [ZMxpvNegativeR]
R of a supplied vector is negative.
The mathematical operation done is
still formally valid.
\item [ZMxpvUnusualTheta]
Theta supplied to construct or set
a vector is outside the range [0,PI].
The mathematical operation done is
still formally valid.  But note that
when sin(theta) < 0, phi becomes an
angle against the -X axis.
\end{description}


\newpage
\section{Names and Keywords}

\subsection {Symbols in the CLHEP Vector Package} 

Here we list the keywords that the user may need to be aware are used by the 
CLHEP Vectors package.  Some symbols not listed here are:

\begin{itemize}
\item
All symbols particular to the ZOOM PhysicsVectors package are listed in 
the next section.  Pure CLHEP users who do not include files fro a ZOOM 
area need not be concerned with these.

\item
Method names in class scope, and names accessible only in the scope of a
class (such as Rotation::IDENTITY) cannot clash with user names.
\end{itemize}

Names of functions defined at global scope do not actually pollute the user
namespace, as long as one or more of their arguments involves a class
defined in this package.  These are therefore listed separately here.

\begin{verbatim}
File Defines                 Class Names
------------                 --------------------------------------------
HEP_THREEVEVCTOR_H 	     Hep3Vector
HEP_LORENTZVECTOR_H          HepLorentzVector
HEP_ROTATION_H               HepRotation  HepRotationX  
                             HepRotationY HepRotationZ
HEP_LORENTZ_ROTATION_H       HepLorentzRotation HepBoost 
                             HepBoostX  HepBoostY  HepBoostZ
HEP_ROTATION_INTERFACES_H    Hep4RotationInterface  Hep3RotationInterface 
                             HepRep3x3  HepRep4x4  HepRep4x4Symmetric  
HEP_EULERANGLES_H            HepEulerAngles
HEP_AXISANGLE_H              HepAxisAngle
\end{verbatim}

\begin{verbatim}
Keywords and Types    Constants      Global Functions
------------------    ---------      ----------------	
Tcomponent            X_HAT4	   rotationOf
TimePositive          Y_HAT4       rotationXOf     
TimeNegative          Z_HAT4       rotationYOf         
		      T_HAT4       rotationZOf     
		      X_HAT2	   boostOf	
		      Y_HAT2	   boostXOf	
                      HepXHat      boostYOf
                      HepYHat      boostZOf
                      HepZHat      inverseOf
\end{verbatim}

\subsection {Further Symbols Defined in ZOOM Headers} 


For backward compatibility, ZOOM headers are made available.  
These typedef classes to the corresponding CLHEP versions, 
and in the two cases of features which were in ZOOM but are not in
CLHEP---{\tt UnitVector} and construction of vectors from 
spherical coordinates---provide the appropriate features.

These ZOOM features are implemented purely at the header level; there
is no separate ZOOM PhysicsVectors library beyond the CLHEP library.

Note that for users including these headers, all symbols starting with
{\tt ZMpv} are to be considered as reserved.  These therefore do not
appear in this list of keywords.

\begin{verbatim}
File Defines                 Class Names
------------                 --------------------------------------------
PHYSICSVECTORS_H 
SPACEVECTOR_H                SpaceVector 
UNITVECTOR_H                 UnitVector
LORENTZVECTOR_H              LorentzVector
ROTATION_H                   Rotation	RotationX  RotationY RotationZ
LORENTZ_TRANSFORMATION_H     LorentzTransformation  LorentzBoost 
                             LorentzBoostX  LorentzBoostY  LorentzBoostZ
EULERANGLES_H                EulerAngles
AXISANGLE_H                  AxisAngle
\end{verbatim}

\begin{verbatim}
Keywords and Types    Constants    
------------------    ---------    
DEGREES               X_HAT        
RADIANS               Y_HAT        
ETA                   Z_HAT        
\end{verbatim}

\end{document}
